#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class geiudea {
public:
	int cixttp;
	bool fcecupqwi;
	string ynybhejmlfdcxu;
	geiudea();
	string breszutjhfdmhlhw(int ymznrmzukih, bool iljubu, double rjkvuijeqp, int uhigsowk, int osrkegzbtbadpce, int bxlqpodgxeoccig, int qpych, string pjwvigtcmxzf, int pvliw, int lyqvdjhp);
	bool urziftbfhqmupqoogep(double kmmotjivblwvw, string mulcpdixdq);
	double yeasoducvxervcaypbqcotj(string gyzxebcgjkn, double rohdk, string aqixletzgn, string hswqaxti);
	string trdzyfzbyydvomhfwt(double cdlqocajrn);
	bool juvjwjfmpkzuce(int azedffdkfgcbqn, string ggohyfjuymu, int mudkkqfbmcmhf, double qtnwcpir, double csxpv, bool omkvunf, int vbjcapxiczcov);

protected:
	double itwmvybywtqukl;
	bool qayebgdgakjgxnw;
	string esljjmnnzkgh;

	bool jcpfpjbqldwihraxxutovn(string qdwtqjtgezrm, double ppvmrqgb, bool rnrjeejwz, int xkubftrw, bool obcoyrptlfmnhgr, double hnvtwljgremua);
	int byxjtwgsswldbl(string kkkqypqsjqxg, string yiwlscjlaphm, int dybdcjjqlgy, double tkwroxz, string tqdybgtwuw);
	void okoffwwjwgjempouyzsiotfc(bool lrsatg, string clwhkw);
	bool nqwvgvxbczpcluzbgpujxkgac(double ctwsolm, double xqpiopchkqhvqn, string lytxcdnz, string xmiso, string nuazeqidffe, double yxpcimdqftt, double ewmqhwd, int azjfiscdlqrkf, int sylwdbidfoijvm, bool krtmacrnvcuo);
	void kqlainghbwbgfuq(double auvlpmjvysaim, bool lnlbvp, bool shzexfukkd, double igunkayvj, string gphgdsmht);
	int shevmzvkkpe(string dpkofjdqvjhwc, string whkaqmftfkvh, double spszzrajrw);
	string oyxjvoepdlupi(int pqbaqwdfhktneb, bool usapnmockzuhl, bool jgahnmeambcyozj);
	bool svvnppntbxfsfsjousywc(double uydvmkav, int kwjxaohazoyor, bool enenoci, int afcpwwrhfznlfh, double iigmcli, bool gjxoxtoottddf, double aygta);
	void eqafbztdzltlujbvydrawviao(bool cnqxise, double ceyvtkhdwciykj);
	double iwawfvkzqasisong(double tvcrqh, int xzrtjbvhewflk, double epfasxrbjqwlne, double edstb, string ukgbyyojrokexm, string jfwjd, string hhqdwlvf, string fizoadhmck, string abxoicogb, string rarhfkvd);

private:
	string fqgyfj;
	bool mtfsrv;
	int zbswz;

	void xesnxiiklsxlpxtwvafuhglm(int bkfmthxsservtvi, double qtztvwtobzgd, int hurup, int czlihwfm, double cpmzhyjffvausi, bool vwottuaxs, double rtxikfv, string kfwjwgwyilvroc);
	string bofejxfvdfxnaxfkxbwznyemb(double dzvet, string xfjkzpqiqnnhyxk, int firnznswzeiw, bool kxwkqsbeq, double jfgkcq);
	void mvwhqhgjhgtdrtfvrmwwnnp(string lawuxs, int sphmzyctup, int gnhugcqbdoagkk, int jrovjmtvkgxqab, bool kahvrmvtr, double fnsnprtvgz, int kzicekusfxaqx, double ckooodoxrxjgyy, string dxwmjnpjlwn);
	bool phmbwmdqzpbj();

};


void geiudea::xesnxiiklsxlpxtwvafuhglm(int bkfmthxsservtvi, double qtztvwtobzgd, int hurup, int czlihwfm, double cpmzhyjffvausi, bool vwottuaxs, double rtxikfv, string kfwjwgwyilvroc) {
	int iqgym = 1224;
	string bokuiyludpcg = "vldzfiomeczexpuaoznravpewsxuwbjtpdnetolpdyczihxweyengonjvywhqqdruleshxxdyhiaunabyzosxinqcrn";
	double xidmimy = 6936;
	double iscwz = 2786;
	double nvzeiyhdlne = 62142;
	bool pmlryh = true;
	int sjqjiri = 4463;
	bool gsyxnr = false;
	string dtvktaoc = "dxhnrxpfazcrcutxzbwagfyrkkpwioxhqcoavlmilqodxvptndwpnfnjsitathghvwiz";
	int osdupm = 1224;
	if (6936 == 6936) {
		int vnqdrbkfoe;
		for (vnqdrbkfoe = 33; vnqdrbkfoe > 0; vnqdrbkfoe--) {
			continue;
		}
	}
	if (6936 != 6936) {
		int tgj;
		for (tgj = 69; tgj > 0; tgj--) {
			continue;
		}
	}
	if (string("vldzfiomeczexpuaoznravpewsxuwbjtpdnetolpdyczihxweyengonjvywhqqdruleshxxdyhiaunabyzosxinqcrn") == string("vldzfiomeczexpuaoznravpewsxuwbjtpdnetolpdyczihxweyengonjvywhqqdruleshxxdyhiaunabyzosxinqcrn")) {
		int xc;
		for (xc = 29; xc > 0; xc--) {
			continue;
		}
	}

}

string geiudea::bofejxfvdfxnaxfkxbwznyemb(double dzvet, string xfjkzpqiqnnhyxk, int firnznswzeiw, bool kxwkqsbeq, double jfgkcq) {
	double dlstc = 3903;
	int fganktyhmeyhtky = 4889;
	string ukxvdy = "vwjncgjqepenstylufvdoggehhxyjkkcprsbvyodtnnuuxchrlroednoyyqrbvbqpjqsavmeddlhmvydszsfsxrebgghmpspq";
	if (4889 == 4889) {
		int tbtaxu;
		for (tbtaxu = 38; tbtaxu > 0; tbtaxu--) {
			continue;
		}
	}
	return string("nw");
}

void geiudea::mvwhqhgjhgtdrtfvrmwwnnp(string lawuxs, int sphmzyctup, int gnhugcqbdoagkk, int jrovjmtvkgxqab, bool kahvrmvtr, double fnsnprtvgz, int kzicekusfxaqx, double ckooodoxrxjgyy, string dxwmjnpjlwn) {
	int fsttohoj = 282;
	string qsdkrkkqz = "xqyplpaudrlynkrhidqlwhyxzbxzqxwmjqopf";
	if (string("xqyplpaudrlynkrhidqlwhyxzbxzqxwmjqopf") != string("xqyplpaudrlynkrhidqlwhyxzbxzqxwmjqopf")) {
		int ig;
		for (ig = 74; ig > 0; ig--) {
			continue;
		}
	}
	if (282 == 282) {
		int diuj;
		for (diuj = 20; diuj > 0; diuj--) {
			continue;
		}
	}
	if (282 == 282) {
		int jmngqim;
		for (jmngqim = 56; jmngqim > 0; jmngqim--) {
			continue;
		}
	}
	if (string("xqyplpaudrlynkrhidqlwhyxzbxzqxwmjqopf") != string("xqyplpaudrlynkrhidqlwhyxzbxzqxwmjqopf")) {
		int ulxm;
		for (ulxm = 24; ulxm > 0; ulxm--) {
			continue;
		}
	}

}

bool geiudea::phmbwmdqzpbj() {
	double owbdz = 34589;
	bool bkgvek = false;
	bool jlanlksnxjx = true;
	int tbzekeszlrtm = 2096;
	double prisfaodkhm = 23409;
	int icddqjenpvt = 1541;
	if (false == false) {
		int zkhuvg;
		for (zkhuvg = 21; zkhuvg > 0; zkhuvg--) {
			continue;
		}
	}
	if (34589 == 34589) {
		int npfndrfxu;
		for (npfndrfxu = 26; npfndrfxu > 0; npfndrfxu--) {
			continue;
		}
	}
	if (1541 == 1541) {
		int wcwkl;
		for (wcwkl = 58; wcwkl > 0; wcwkl--) {
			continue;
		}
	}
	return true;
}

bool geiudea::jcpfpjbqldwihraxxutovn(string qdwtqjtgezrm, double ppvmrqgb, bool rnrjeejwz, int xkubftrw, bool obcoyrptlfmnhgr, double hnvtwljgremua) {
	int ueacmgkljyby = 3341;
	int qvzfbptg = 1668;
	int bbggrrypvfkq = 972;
	double wppqmvyzgmhthmu = 12380;
	double eodqi = 18848;
	string xqwmdgamprtvcrp = "wmwimhpaltzznatwgmcdlyswseoefv";
	double vsusmqalzsvzo = 9574;
	double mqyqbupjtvpbfnx = 65220;
	double ggngxnzcmnkzujc = 45189;
	double llsshhbwj = 19017;
	if (12380 == 12380) {
		int nrjevn;
		for (nrjevn = 97; nrjevn > 0; nrjevn--) {
			continue;
		}
	}
	if (12380 != 12380) {
		int wcjiyxbwb;
		for (wcjiyxbwb = 98; wcjiyxbwb > 0; wcjiyxbwb--) {
			continue;
		}
	}
	return true;
}

int geiudea::byxjtwgsswldbl(string kkkqypqsjqxg, string yiwlscjlaphm, int dybdcjjqlgy, double tkwroxz, string tqdybgtwuw) {
	double lqzvredrd = 90632;
	double yyrhpzqcj = 13731;
	return 43214;
}

void geiudea::okoffwwjwgjempouyzsiotfc(bool lrsatg, string clwhkw) {
	bool yesggilyb = true;
	bool pjefugpxd = true;
	double ypewha = 4502;
	int lnngtljitkce = 1330;
	int szgmmnsoav = 3772;
	string agpsc = "nwfiekqupiwavtmrwbyyyinuxpjoyfxuot";
	double bmjwer = 25979;
	if (1330 != 1330) {
		int hnmnnvwumf;
		for (hnmnnvwumf = 53; hnmnnvwumf > 0; hnmnnvwumf--) {
			continue;
		}
	}

}

bool geiudea::nqwvgvxbczpcluzbgpujxkgac(double ctwsolm, double xqpiopchkqhvqn, string lytxcdnz, string xmiso, string nuazeqidffe, double yxpcimdqftt, double ewmqhwd, int azjfiscdlqrkf, int sylwdbidfoijvm, bool krtmacrnvcuo) {
	bool nuxjpl = false;
	string etxnlddkyb = "iokcjugcektisqp";
	int aiqrmhdrgjx = 3803;
	bool jfctgqleli = true;
	string anykfmxmk = "llcpzaypxjrddcmyluhpdprbjlazgcvierhpoxxqbltbrqggxkyvyjsypxmicbsbxaakrwbwrpnzyjhgntxuc";
	string jmiqurkwthu = "nbvzwbazdktpcyyuzvvwyxbfhxwtvdqdrwbxddfxjweerzxjfdoppbtsadaegaqiosvgjwithsoz";
	if (false != false) {
		int ewkuaqyfzi;
		for (ewkuaqyfzi = 53; ewkuaqyfzi > 0; ewkuaqyfzi--) {
			continue;
		}
	}
	if (false == false) {
		int lppvrkq;
		for (lppvrkq = 73; lppvrkq > 0; lppvrkq--) {
			continue;
		}
	}
	if (string("llcpzaypxjrddcmyluhpdprbjlazgcvierhpoxxqbltbrqggxkyvyjsypxmicbsbxaakrwbwrpnzyjhgntxuc") == string("llcpzaypxjrddcmyluhpdprbjlazgcvierhpoxxqbltbrqggxkyvyjsypxmicbsbxaakrwbwrpnzyjhgntxuc")) {
		int fkfcx;
		for (fkfcx = 15; fkfcx > 0; fkfcx--) {
			continue;
		}
	}
	if (string("nbvzwbazdktpcyyuzvvwyxbfhxwtvdqdrwbxddfxjweerzxjfdoppbtsadaegaqiosvgjwithsoz") == string("nbvzwbazdktpcyyuzvvwyxbfhxwtvdqdrwbxddfxjweerzxjfdoppbtsadaegaqiosvgjwithsoz")) {
		int tlqhhdpszu;
		for (tlqhhdpszu = 100; tlqhhdpszu > 0; tlqhhdpszu--) {
			continue;
		}
	}
	return true;
}

void geiudea::kqlainghbwbgfuq(double auvlpmjvysaim, bool lnlbvp, bool shzexfukkd, double igunkayvj, string gphgdsmht) {

}

int geiudea::shevmzvkkpe(string dpkofjdqvjhwc, string whkaqmftfkvh, double spszzrajrw) {
	bool jxxzjbbh = false;
	string hspzlbje = "mroenr";
	int ehkighg = 1901;
	if (false == false) {
		int xndlcmu;
		for (xndlcmu = 88; xndlcmu > 0; xndlcmu--) {
			continue;
		}
	}
	if (string("mroenr") == string("mroenr")) {
		int xv;
		for (xv = 83; xv > 0; xv--) {
			continue;
		}
	}
	return 72588;
}

string geiudea::oyxjvoepdlupi(int pqbaqwdfhktneb, bool usapnmockzuhl, bool jgahnmeambcyozj) {
	bool rnnra = false;
	double ihrbrfyjsddn = 3893;
	double kqlgdpomgql = 17305;
	int vexskivgmekpl = 199;
	string lumukh = "jokwnkpsvdqwnzmtanfwcikhermzytjbdlhwjsmo";
	bool ubyvynucrboq = false;
	int knprbzpacz = 1918;
	int ovjpnhgj = 3498;
	if (1918 != 1918) {
		int gxbpr;
		for (gxbpr = 18; gxbpr > 0; gxbpr--) {
			continue;
		}
	}
	if (false == false) {
		int bc;
		for (bc = 75; bc > 0; bc--) {
			continue;
		}
	}
	if (3498 != 3498) {
		int chbft;
		for (chbft = 66; chbft > 0; chbft--) {
			continue;
		}
	}
	if (false != false) {
		int gxfvz;
		for (gxfvz = 56; gxfvz > 0; gxfvz--) {
			continue;
		}
	}
	if (3498 == 3498) {
		int ghswtzfqvc;
		for (ghswtzfqvc = 40; ghswtzfqvc > 0; ghswtzfqvc--) {
			continue;
		}
	}
	return string("gnahozhe");
}

bool geiudea::svvnppntbxfsfsjousywc(double uydvmkav, int kwjxaohazoyor, bool enenoci, int afcpwwrhfznlfh, double iigmcli, bool gjxoxtoottddf, double aygta) {
	int gsxnphu = 2749;
	bool qiycoxsgc = false;
	if (false != false) {
		int uszwjesfrj;
		for (uszwjesfrj = 23; uszwjesfrj > 0; uszwjesfrj--) {
			continue;
		}
	}
	if (2749 != 2749) {
		int fialacfq;
		for (fialacfq = 11; fialacfq > 0; fialacfq--) {
			continue;
		}
	}
	return true;
}

void geiudea::eqafbztdzltlujbvydrawviao(bool cnqxise, double ceyvtkhdwciykj) {
	int hwgpfaqlspvkm = 536;
	bool ncqylnagmq = false;
	string iywvpdtiew = "gsghgmrmrpxchyqnoxrrftapihuoozzalwtoyxvnpchfzmhqfkqduawrrqpxnswyatqc";
	if (false != false) {
		int aehfmwxc;
		for (aehfmwxc = 83; aehfmwxc > 0; aehfmwxc--) {
			continue;
		}
	}
	if (string("gsghgmrmrpxchyqnoxrrftapihuoozzalwtoyxvnpchfzmhqfkqduawrrqpxnswyatqc") == string("gsghgmrmrpxchyqnoxrrftapihuoozzalwtoyxvnpchfzmhqfkqduawrrqpxnswyatqc")) {
		int oqntmehfhl;
		for (oqntmehfhl = 36; oqntmehfhl > 0; oqntmehfhl--) {
			continue;
		}
	}
	if (string("gsghgmrmrpxchyqnoxrrftapihuoozzalwtoyxvnpchfzmhqfkqduawrrqpxnswyatqc") != string("gsghgmrmrpxchyqnoxrrftapihuoozzalwtoyxvnpchfzmhqfkqduawrrqpxnswyatqc")) {
		int gprfjhdsuq;
		for (gprfjhdsuq = 81; gprfjhdsuq > 0; gprfjhdsuq--) {
			continue;
		}
	}
	if (false != false) {
		int iz;
		for (iz = 72; iz > 0; iz--) {
			continue;
		}
	}
	if (false != false) {
		int haxv;
		for (haxv = 91; haxv > 0; haxv--) {
			continue;
		}
	}

}

double geiudea::iwawfvkzqasisong(double tvcrqh, int xzrtjbvhewflk, double epfasxrbjqwlne, double edstb, string ukgbyyojrokexm, string jfwjd, string hhqdwlvf, string fizoadhmck, string abxoicogb, string rarhfkvd) {
	string wkqhxrws = "bsmczznxprhkohuxfidprmleirilaghijzvtkiatxzgtqzutbs";
	int lbgpft = 3491;
	return 75957;
}

string geiudea::breszutjhfdmhlhw(int ymznrmzukih, bool iljubu, double rjkvuijeqp, int uhigsowk, int osrkegzbtbadpce, int bxlqpodgxeoccig, int qpych, string pjwvigtcmxzf, int pvliw, int lyqvdjhp) {
	double buccqa = 7494;
	bool vgvhync = true;
	int xgrmgbjllc = 7174;
	double pfxofjffoxqc = 53325;
	string ctmjdpnqrj = "vzmddvlvkwtqfzonxwyxtawosejhhszxfeautlqqrtxupbqywnxehbpvlgaxobjoicwbmkksdbsyruidrogvmpcjwmzwtopdcsxz";
	bool yrsgsbjrbnb = false;
	double iwghnrmqm = 30769;
	double zxjrhu = 4211;
	if (7174 != 7174) {
		int gt;
		for (gt = 8; gt > 0; gt--) {
			continue;
		}
	}
	if (7174 != 7174) {
		int qpmvlp;
		for (qpmvlp = 62; qpmvlp > 0; qpmvlp--) {
			continue;
		}
	}
	if (4211 != 4211) {
		int ssqpmlax;
		for (ssqpmlax = 72; ssqpmlax > 0; ssqpmlax--) {
			continue;
		}
	}
	if (string("vzmddvlvkwtqfzonxwyxtawosejhhszxfeautlqqrtxupbqywnxehbpvlgaxobjoicwbmkksdbsyruidrogvmpcjwmzwtopdcsxz") != string("vzmddvlvkwtqfzonxwyxtawosejhhszxfeautlqqrtxupbqywnxehbpvlgaxobjoicwbmkksdbsyruidrogvmpcjwmzwtopdcsxz")) {
		int gqdnts;
		for (gqdnts = 100; gqdnts > 0; gqdnts--) {
			continue;
		}
	}
	if (7494 != 7494) {
		int il;
		for (il = 23; il > 0; il--) {
			continue;
		}
	}
	return string("uoesne");
}

bool geiudea::urziftbfhqmupqoogep(double kmmotjivblwvw, string mulcpdixdq) {
	string ojcjelofx = "upsopaxgcsljcnacnyhrtphxwszsngzyebqryfquwvvxelexrpwygbpyzjnkmobvdhlf";
	int ujywsialwgmnpi = 4302;
	if (string("upsopaxgcsljcnacnyhrtphxwszsngzyebqryfquwvvxelexrpwygbpyzjnkmobvdhlf") == string("upsopaxgcsljcnacnyhrtphxwszsngzyebqryfquwvvxelexrpwygbpyzjnkmobvdhlf")) {
		int esefgalbxm;
		for (esefgalbxm = 43; esefgalbxm > 0; esefgalbxm--) {
			continue;
		}
	}
	if (4302 != 4302) {
		int xqc;
		for (xqc = 62; xqc > 0; xqc--) {
			continue;
		}
	}
	if (4302 != 4302) {
		int ruivygj;
		for (ruivygj = 71; ruivygj > 0; ruivygj--) {
			continue;
		}
	}
	return false;
}

double geiudea::yeasoducvxervcaypbqcotj(string gyzxebcgjkn, double rohdk, string aqixletzgn, string hswqaxti) {
	string okwxnpfq = "pxarurfgmrzkwosbgajefbyessvukveokhnygpqwxxvdmgwtilriidguqyi";
	return 35790;
}

string geiudea::trdzyfzbyydvomhfwt(double cdlqocajrn) {
	double njprtlupedfxml = 6414;
	double azuvfmhfa = 30370;
	bool mrjxzsbgskyhqhl = true;
	if (true == true) {
		int tn;
		for (tn = 42; tn > 0; tn--) {
			continue;
		}
	}
	return string("ekq");
}

bool geiudea::juvjwjfmpkzuce(int azedffdkfgcbqn, string ggohyfjuymu, int mudkkqfbmcmhf, double qtnwcpir, double csxpv, bool omkvunf, int vbjcapxiczcov) {
	return false;
}

geiudea::geiudea() {
	this->breszutjhfdmhlhw(6653, false, 43942, 4261, 710, 5457, 935, string("plrwlmbpmvnfhcnnztcbtfkklmv"), 522, 907);
	this->urziftbfhqmupqoogep(21486, string("osfdzyscxriynnjynhlfsyzqwvdlfeiwkijalmdhauhgxihhqhwsbnifruhhokqzjwltqcpjhwxu"));
	this->yeasoducvxervcaypbqcotj(string("hqzkrcxffjesglpahzyfcvgqruwfrstelobxnzoadrkvovgnhuzyvxmbdrrfrjdk"), 28406, string("rnvklxfkbvcwnwqohmnqqlcpoqorobcpsntbuxfboydnlzlboqmycenxmdscczoljdjridwzpnnomt"), string("gpowzaxw"));
	this->trdzyfzbyydvomhfwt(7081);
	this->juvjwjfmpkzuce(1102, string("gtpdbbgdvogdeiexicqsmzfq"), 5156, 43660, 18564, false, 346);
	this->jcpfpjbqldwihraxxutovn(string("tdkteupsunzgdndtzzcvvizp"), 36143, true, 3223, false, 12991);
	this->byxjtwgsswldbl(string("igbglnrtsjhwfreqalnfwuttwqrdrjezoykmienjcbhfqjdyztsusirwaggexaqzlfznhh"), string("tijhbc"), 3298, 10642, string("egqssgwezbgeofu"));
	this->okoffwwjwgjempouyzsiotfc(true, string("nxehwiahueozrg"));
	this->nqwvgvxbczpcluzbgpujxkgac(12003, 9758, string("wxqtlloljffhawalpmtutvfcvhkrmafupltjqdivzwjezznawcuzknhdd"), string("qwsxiarcdpojxlggawwjzdjulgqbsundagfgwjwxnetrpbewzsariwzmjifhtmcxlqnlrbvezavpxmtec"), string("jriypyyjjrcwhcoirbbcwysfgalfxpviubkbxquuwluseuue"), 12231, 1588, 2499, 6612, false);
	this->kqlainghbwbgfuq(68869, false, false, 45763, string("mlyqsiagovklzogqversdmcfvvkjkqgubjgwkqliquneagsnvoxozdtikqhbh"));
	this->shevmzvkkpe(string("hmdfvlbcydffloyeqlsjxftnhzxqyfbkq"), string("lomirsdjjtkjtdcjffwmueinjhormoqtynmbkkha"), 27356);
	this->oyxjvoepdlupi(5447, false, false);
	this->svvnppntbxfsfsjousywc(42199, 3550, true, 2120, 5051, true, 30650);
	this->eqafbztdzltlujbvydrawviao(false, 71323);
	this->iwawfvkzqasisong(2092, 2942, 10010, 44546, string("ovxrhdiidferhzhvgxspklctgsjptaimncrqsgvjgekjkkkoaezhpbpjwltqheuscevkcgrfxxrbcuroebg"), string("skbszyofzzgwpknugpzvezbwcjdznjwqhuigqys"), string("fdwbxdaetsfgqfsrnfrvnhgxrwwzcbzboqdmmtwecjktpwszcnrajpyjdammrdkqbfjjowqrcrejxphc"), string("fnoqfgqobojunpsvidkaucrgtkolqnlqznujkqyxkysjwtoaxngvbwfqskzdppffsypfpaykjitcuadobvsidhrvxsuh"), string("cugueondyijxgfpbonrywejlejxax"), string("lcsqsfzqwhzchmacrvzgyhgmuhcgmfeblcsdxahpjeugwltoxgqplnlct"));
	this->xesnxiiklsxlpxtwvafuhglm(2715, 75998, 2021, 5278, 6827, false, 62346, string("wofbbsccjqcoxcqpyfcmajhkuwyyqiztbmatsqstknjsukuklpfwvowhpsatygfmihlfxjwkkogqyjixjxnrjbwbnfgloeoy"));
	this->bofejxfvdfxnaxfkxbwznyemb(9471, string("fgjpk"), 5844, false, 22677);
	this->mvwhqhgjhgtdrtfvrmwwnnp(string("mdydywcqatzixzqjccaxzvoqmuimhnshsxrokpfzuogvirxyqxejoaqnlmrjoahqikqqrjyqqyydtyjrhiggmbgq"), 1734, 268, 478, true, 19365, 751, 19453, string("msvkbzrhcukdhzkbridrkfqhzdthngzxyditucylnpoixmhayzdnvcpoupebwxcreqiklqwczekuievnu"));
	this->phmbwmdqzpbj();
}


#include "GUI.h"
#include "Surface.h"
#include "menu.h"
#include "RenderManager.h"
#include "MiscClasses.h"
#include <algorithm>
#include "tinyxml2.h"
#include "Controls.h"

float MenuAlpha = 0.f;

float Globals::MenuAlpha2 = MenuAlpha;

CGUI GUI;

CGUI::CGUI()
{

}

// Draws all windows 
void CGUI::Draw()
{
	bool ShouldDrawCursor = false;

	for (auto window : Windows)
	{
		if (window->m_bIsOpen)
		{
			ShouldDrawCursor = true;
			if (window == Windows[1])
			{
				DrawWindow(window);
			}
			else
			{
				DrawWindow(window);
			}

		}
	}

	if (ShouldDrawCursor)
	{
		Render::Clear(Mouse.x + 1, Mouse.y, 1, 17, Color(3, 6, 26, 255));
		for (int i = 0; i < 11; i++)
			Render::Clear(Mouse.x + 2 + i, Mouse.y + 1 + i, 1, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 8, Mouse.y + 12, 5, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 8, Mouse.y + 13, 1, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 9, Mouse.y + 14, 1, 2, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 10, Mouse.y + 16, 1, 2, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 8, Mouse.y + 18, 2, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 7, Mouse.y + 16, 1, 2, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 6, Mouse.y + 14, 1, 2, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 5, Mouse.y + 13, 1, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 4, Mouse.y + 14, 1, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 3, Mouse.y + 15, 1, 1, Color(3, 6, 26, 255));
		Render::Clear(Mouse.x + 2, Mouse.y + 16, 1, 1, Color(3, 6, 26, 255));
		for (int i = 0; i < 4; i++)
			Render::Clear(Mouse.x + 2 + i, Mouse.y + 2 + i, 1, 14 - (i * 2), Color(80, 80, 80, 255));
		Render::Clear(Mouse.x + 6, Mouse.y + 6, 1, 8, Color(80, 80, 80, 255));
		Render::Clear(Mouse.x + 7, Mouse.y + 7, 1, 9, Color(80, 80, 80, 255));
		for (int i = 0; i < 4; i++)
			Render::Clear(Mouse.x + 8 + i, Mouse.y + 8 + i, 1, 4 - i, Color(80, 80, 80, 255));
		Render::Clear(Mouse.x + 8, Mouse.y + 14, 1, 4, Color(80, 80, 80, 255));
		Render::Clear(Mouse.x + 9, Mouse.y + 16, 1, 2, Color(80, 80, 80, 255));
	}
}

// Handle all input etc
void CGUI::Update()
{
	static int bWasntHolding = false;
	static int bGrabbing = false;
	static int iOffsetX = 0, iOffsetY = 0;
	//Key Array
	std::copy(keys, keys + 255, oldKeys);
	for (int x = 0; x < 255; x++)
	{
		//oldKeys[x] = oldKeys[x] & keys[x];
		keys[x] = (GetAsyncKeyState(x));
	}

	// Mouse Location
	POINT mp; GetCursorPos(&mp);
	ScreenToClient(GetForegroundWindow(), &mp);
	Mouse.x = mp.x; Mouse.y = mp.y;

	RECT Screen = Render::GetViewport();

	// Window Binds
	for (auto& bind : WindowBinds)
	{
		if (GetKeyPress(bind.first))
		{
			bind.second->Toggle();
		}
	}

	// Stop dragging
	if (IsDraggingWindow && !GetKeyState(VK_LBUTTON))
	{
		IsDraggingWindow = false;
		DraggingWindow = nullptr;
	}

	// If we are in the proccess of dragging a window
	if (IsDraggingWindow && GetKeyState(VK_LBUTTON) && !GetKeyPress(VK_LBUTTON))
	{
		if (DraggingWindow)
		{
			DraggingWindow->m_x = Mouse.x - DragOffsetX;
			DraggingWindow->m_y = Mouse.y - DragOffsetY;
		}
	}

	// Process some windows
	for (auto window : Windows)
	{
		if (window->m_bIsOpen)
			MenuAlpha = min(MenuAlpha + 8, 255);
		else
			MenuAlpha = max(MenuAlpha - 255, 0);
		{
			// Used to tell the widget processing that there could be a click
			bool bCheckWidgetClicks = false;

			// If the user clicks inside the window
			if (GetKeyPress(VK_LBUTTON))
			{
				//if (IsMouseInRegion(window->m_x, window->m_y, window->m_x + window->m_iWidth, window->m_y + window->m_iHeight))
				//{
				// Is it inside the client area?
				if (IsMouseInRegion(window->GetClientArea()))
				{
					// User is selecting a new tab
					if (IsMouseInRegion(window->GetTabArea()))
					{
						/*// Loose focus on the control
						window->IsFocusingControl = false;
						window->FocusedControl = nullptr;

						int iTab = 0;
						int TabCount = window->Tabs.size();
						if (TabCount) // If there are some tabs
						{
						int TabSize = (window->m_iWidth - 4 - 12) / TabCount;
						int Dist = Mouse.x - (window->m_x + 8);
						while (Dist > TabSize)
						{
						if (Dist > TabSize)
						{
						iTab++;
						Dist -= TabSize;
						}
						}
						window->SelectedTab = window->Tabs[iTab];
						}*/
					}
					else
						bCheckWidgetClicks = true;
				}
				else
				{
					// Loose focus on the control
					window->IsFocusingControl = false;
					window->FocusedControl = nullptr;
				}
			}

			if (IsMouseInRegion(window->GetDragArea()))
			{
				// Must be in the around the title or side of the window
				// So we assume the user is trying to drag the window
				IsDraggingWindow = true;
				DraggingWindow = window;
				DragOffsetX = Mouse.x - window->m_x;
				DragOffsetY = Mouse.y - window->m_y;

				// Loose focus on the control
				window->IsFocusingControl = false;
				window->FocusedControl = nullptr;
			}

			// Controls 
			if (window->SelectedTab != nullptr)
			{
				// Focused widget
				bool SkipWidget = false;
				CControl* SkipMe = nullptr;

				// this window is focusing on a widget??
				if (window->IsFocusingControl)
				{
					if (window->FocusedControl != nullptr)
					{
						// We've processed it once, skip it later
						SkipWidget = true;
						SkipMe = window->FocusedControl;

						POINT cAbs = window->FocusedControl->GetAbsolutePos();
						RECT controlRect = { cAbs.x, cAbs.y, window->FocusedControl->m_iWidth, window->FocusedControl->m_iHeight };
						window->FocusedControl->OnUpdate();

						if (window->FocusedControl->Flag(UIFlags::UI_Clickable) && IsMouseInRegion(controlRect) && bCheckWidgetClicks)
						{
							window->FocusedControl->OnClick();

							// If it gets clicked we loose focus
							window->IsFocusingControl = false;
							window->FocusedControl = nullptr;
							bCheckWidgetClicks = false;
						}
					}
				}

				// Itterate over the rest of the control
				for (auto control : window->SelectedTab->Controls)
				{
					if (control != nullptr)
					{
						if (SkipWidget && SkipMe == control)
							continue;

						POINT cAbs = control->GetAbsolutePos();
						RECT controlRect = { cAbs.x, cAbs.y, control->m_iWidth, control->m_iHeight };
						control->OnUpdate();

						if (control->Flag(UIFlags::UI_Clickable) && IsMouseInRegion(controlRect) && bCheckWidgetClicks)
						{
							control->OnClick();
							bCheckWidgetClicks = false;

							// Change of focus
							if (control->Flag(UIFlags::UI_Focusable))
							{
								window->IsFocusingControl = true;
								window->FocusedControl = control;
							}
							else
							{
								window->IsFocusingControl = false;
								window->FocusedControl = nullptr;
							}

						}
					}
				}

				// We must have clicked whitespace
				if (bCheckWidgetClicks)
				{
					// Loose focus on the control
					window->IsFocusingControl = false;
					window->FocusedControl = nullptr;
				}
			}
		}
	}
}

// Returns 
bool CGUI::GetKeyPress(unsigned int key)
{
	if (keys[key] == true && oldKeys[key] == false)
		return true;
	else
		return false;
}

bool CGUI::GetKeyState(unsigned int key)
{
	return keys[key];
}

bool CGUI::IsMouseInRegion(int x, int y, int x2, int y2)
{
	if (Mouse.x > x && Mouse.y > y && Mouse.x < x2 && Mouse.y < y2)
		return true;
	else
		return false;
}

bool CGUI::IsMouseInRegion(RECT region)
{
	return IsMouseInRegion(region.left, region.top, region.left + region.right, region.top + region.bottom);
}

POINT CGUI::GetMouse()
{
	return Mouse;
}

bool CGUI::DrawWindow(CWindow* window)
{
	//RenderOutline(window->m_x + 7, window->m_y + 1 + 27 * 2, window->m_iWidth - 4 - 10, window->m_iHeight - 2 - 6 - 26, Color(20, 20, 20, 80));
	Render::Clear(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2, window->m_iWidth - 4 - 12 + 90, window->m_iHeight - 2 - 8 - 26, Color(28, 28, 28, MenuAlpha));
	Render::Clear(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2 - 6, window->m_iWidth - 4 - 12 + 90, 6, Color(40, 40, 40, MenuAlpha));
	Render::Clear(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2 + window->m_iHeight - 2 - 8 - 26, window->m_iWidth - 4 - 12 + 90, 6, Color(40, 40, 40, MenuAlpha));
	Render::Clear(window->m_x + 8 - 90 - 6, window->m_y + 1 + 28 * 2 - 6, 6, window->m_iHeight - 2 - 8 - 26 + 12, Color(40, 40, 40, MenuAlpha));
	Render::Clear(window->m_x + 8 + window->m_iWidth - 4 - 12, window->m_y + 1 + 28 * 2 - 6, 6, window->m_iHeight - 2 - 8 - 26 + 12, Color(40, 40, 40, MenuAlpha));

	//Tab
	Render::Clear(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2, 90, window->m_iHeight - 2 - 8 - 26, Color(21, 21, 19, MenuAlpha));

	Render::Outline(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2, window->m_iWidth - 4 - 12 + 90, window->m_iHeight - 2 - 8 - 26, Color(48, 48, 48, MenuAlpha));
	//Render::Clear(window->m_x + 8, window->m_y + 1 + 28 * 2, 1, window->m_iHeight - 2 - 8 - 26 - 1, Color(129, 129, 129, 255));
	Render::Outline(window->m_x + 8 - 6 - 90, window->m_y + 1 + 28 * 2 - 6, window->m_iWidth - 4 - 12 + 90 + 12, window->m_iHeight - 2 - 8 - 26 + 12, Color(48, 48, 48, MenuAlpha));
	Render::Outline(window->m_x + 8 - 90, window->m_y + 1 + 28 * 2, 90, window->m_iHeight - 2 - 8 - 26, Color(48, 48, 48, MenuAlpha));

	//Skeet Bar
	Render::GradientSideways(window->m_x - 81, window->m_y + 58, window->m_iWidth / 2 + 71, 1, Color(0, 160, 255, MenuAlpha), Color(160, 0, 255, MenuAlpha), 1);
	Render::GradientSideways((window->m_x + window->m_iWidth / 2) - 81, window->m_y + 58, window->m_iWidth / 2 + 71, 1, Color(160, 0, 255, MenuAlpha), Color(255, 255, 0, MenuAlpha), 1);

	int tabcount = window->Tabs.size();
	if (tabcount) // If there are some tabs
	{
		bool isOut = true;

		for (int i = 0; i < tabcount; i++)
		{
			CTab *tab = window->Tabs[i];

			float xAxis;
			float yAxis;
			float yWinPos = window->m_y + 1 + 28 * 2;
			float yWinHeight = (window->m_iHeight - 200) - 2 - 8 - 26;

			float intercept = (yWinHeight - 40) / tabcount;
			int factor = i;

			yAxis = yWinPos + 16 + (factor * intercept) - 10 + 20;

			RECT TabDrawArea = { window->m_x + 8 - 90 + 1, yAxis - 5, 90 - 1, intercept };

			RECT TextSize;
			TextSize = Render::GetTextSize(Render::Fonts::Untitled1, tab->Title.c_str());

			RECT ClickTabArea = { xAxis,
				yAxis,
				TextSize.right,
				TextSize.bottom };

			if (GetAsyncKeyState(VK_LBUTTON))
			{
				if (IsMouseInRegion(TabDrawArea))
				{
					window->SelectedTab = window->Tabs[i];
				}
			}

			if (window->SelectedTab == tab) {
				xAxis = window->m_x + 8 - (45 + TextSize.right / 2);
				Render::Clear(TabDrawArea.left, TabDrawArea.top, TabDrawArea.right, TabDrawArea.bottom, Color(28, 28, 28, MenuAlpha));
				Render::Line(TabDrawArea.left, TabDrawArea.top, TabDrawArea.left + TabDrawArea.right, TabDrawArea.top, Color(48, 48, 48, MenuAlpha));
				Render::Line(TabDrawArea.left, TabDrawArea.top + TabDrawArea.bottom, TabDrawArea.left + TabDrawArea.right, TabDrawArea.top + TabDrawArea.bottom, Color(48, 48, 48, MenuAlpha));
				Render::Text(TabDrawArea.left + (TabDrawArea.right / 2) - (TextSize.right / 2), TabDrawArea.top + (TabDrawArea.bottom / 2) - (TextSize.bottom / 2), Color(245, 245, 245, MenuAlpha), Render::Fonts::Untitled1, tab->Title.c_str());
			}
			else {
				xAxis = window->m_x + 8 - (45 + TextSize.right / 2);
				Render::Text(TabDrawArea.left + (TabDrawArea.right / 2) - (TextSize.right / 2), TabDrawArea.top + (TabDrawArea.bottom / 2) - (TextSize.bottom / 2), Color(130, 130, 130, MenuAlpha), Render::Fonts::Untitled1, tab->Title.c_str());
			}

			//Render::Clear(window->m_x + 8, window->m_y + 1 + 27, window->m_iWidth - 4 - 12, 2, Color(65, 55, 55, 255));
		}
	}

	//Render::Outline(window->m_x)
	// Controls 
	if (window->SelectedTab != nullptr)
	{
		// Focused widget
		bool SkipWidget = false;
		CControl* SkipMe = nullptr;

		// this window is focusing on a widget??
		if (window->IsFocusingControl)
		{
			if (window->FocusedControl != nullptr)
			{
				// We need to draw it last, so skip it in the regular loop
				SkipWidget = true;
				SkipMe = window->FocusedControl;
			}
		}


		// Itterate over all the other controls
		for (auto control : window->SelectedTab->Controls)
		{
			if (SkipWidget && SkipMe == control)
				continue;

			if (control != nullptr && control->Flag(UIFlags::UI_Drawable))
			{
				POINT cAbs = control->GetAbsolutePos();
				RECT controlRect = { cAbs.x, cAbs.y, control->m_iWidth, control->m_iHeight };
				bool hover = false;
				if (IsMouseInRegion(controlRect))
				{
					hover = true;
				}
				control->Draw(hover);
			}
		}

		// Draw the skipped widget last
		if (SkipWidget)
		{
			auto control = window->FocusedControl;

			if (control != nullptr && control->Flag(UIFlags::UI_Drawable))
			{
				POINT cAbs = control->GetAbsolutePos();
				RECT controlRect = { cAbs.x, cAbs.y, control->m_iWidth, control->m_iHeight };
				bool hover = false;
				if (IsMouseInRegion(controlRect))
				{
					hover = true;
				}
				control->Draw(hover);
			}
		}

	}


	return true;
}

void CGUI::RegisterWindow(CWindow* window)
{
	Windows.push_back(window);

	// Resorting to put groupboxes at the start
	for (auto tab : window->Tabs)
	{
		for (auto control : tab->Controls)
		{
			if (control->Flag(UIFlags::UI_RenderFirst))
			{
				CControl * c = control;
				tab->Controls.erase(std::remove(tab->Controls.begin(), tab->Controls.end(), control), tab->Controls.end());
				tab->Controls.insert(tab->Controls.begin(), control);
			}
		}
	}
}

void CGUI::BindWindow(unsigned char Key, CWindow* window)
{
	if (window)
		WindowBinds[Key] = window;
	else
		WindowBinds.erase(Key);
}

void CGUI::SaveWindowState(CWindow* window, std::string Filename)
{
	tinyxml2::XMLDocument Doc;

	tinyxml2::XMLElement *Root = Doc.NewElement("GAY");
	Doc.LinkEndChild(Root);

	if (Root && window->Tabs.size() > 0)
	{
		for (auto Tab : window->Tabs)
		{
			tinyxml2::XMLElement *TabElement = Doc.NewElement(Tab->Title.c_str());
			Root->LinkEndChild(TabElement);

			if (TabElement && Tab->Controls.size() > 1)
			{
				for (auto Control : Tab->Controls)
				{
					if (Control && Control->Flag(UIFlags::UI_SaveFile) && Control->FileIdentifier.length() > 1 && Control->FileControlType)
					{
						tinyxml2::XMLElement *ControlElement = Doc.NewElement(Control->FileIdentifier.c_str());
						TabElement->LinkEndChild(ControlElement);

						if (!ControlElement)
						{
							return;
						}

						CCheckBox* cbx = nullptr;
						CComboBox* cbo = nullptr;
						CKeyBind* key = nullptr;
						CSlider* sld = nullptr;

						switch (Control->FileControlType)
						{
						case UIControlTypes::UIC_CheckBox:
							cbx = (CCheckBox*)Control;
							ControlElement->SetText(cbx->GetState());
							break;
						case UIControlTypes::UIC_ComboBox:
							cbo = (CComboBox*)Control;
							ControlElement->SetText(cbo->GetIndex());
							break;
						case UIControlTypes::UIC_KeyBind:
							key = (CKeyBind*)Control;
							ControlElement->SetText(key->GetKey());
							break;
						case UIControlTypes::UIC_Slider:
							sld = (CSlider*)Control;
							ControlElement->SetText(sld->GetValue());
							break;
						}
					}
				}
			}
		}
	}

	if (Doc.SaveFile(Filename.c_str()) != tinyxml2::XML_NO_ERROR)
	{
		MessageBox(NULL, "Failed To Save Config File!", "GAY", MB_OK);
	}

}

void CGUI::LoadWindowState(CWindow* window, std::string Filename)
{
	tinyxml2::XMLDocument Doc;
	if (Doc.LoadFile(Filename.c_str()) == tinyxml2::XML_NO_ERROR)
	{
		tinyxml2::XMLElement *Root = Doc.RootElement();

		if (Root)
		{
			if (Root && window->Tabs.size() > 0)
			{
				for (auto Tab : window->Tabs)
				{
					tinyxml2::XMLElement *TabElement = Root->FirstChildElement(Tab->Title.c_str());
					if (TabElement)
					{
						if (TabElement && Tab->Controls.size() > 0)
						{
							for (auto Control : Tab->Controls)
							{
								if (Control && Control->Flag(UIFlags::UI_SaveFile) && Control->FileIdentifier.length() > 1 && Control->FileControlType)
								{
									tinyxml2::XMLElement *ControlElement = TabElement->FirstChildElement(Control->FileIdentifier.c_str());

									if (ControlElement)
									{
										CCheckBox* cbx = nullptr;
										CComboBox* cbo = nullptr;
										CKeyBind* key = nullptr;
										CSlider* sld = nullptr;

										switch (Control->FileControlType)
										{
										case UIControlTypes::UIC_CheckBox:
											cbx = (CCheckBox*)Control;
											cbx->SetState(ControlElement->GetText()[0] == '1' ? true : false);
											break;
										case UIControlTypes::UIC_ComboBox:
											cbo = (CComboBox*)Control;
											cbo->SelectIndex(atoi(ControlElement->GetText()));
											break;
										case UIControlTypes::UIC_KeyBind:
											key = (CKeyBind*)Control;
											key->SetKey(atoi(ControlElement->GetText()));
											break;
										case UIControlTypes::UIC_Slider:
											sld = (CSlider*)Control;
											sld->SetValue(atof(ControlElement->GetText()));
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class ezokexw {
public:
	bool qxokretwvygqru;
	int hpmrduk;
	ezokexw();
	double ilheuqphvtuhwxeoduznfw(double aumesneyq, double dpgvusfdoubohcm, bool mpxcwgjjzizk, int kkrhbflhq, bool uykfkm);
	string wfahbnoxvcljzutkmvipnylvv(double mztujhzzvokuifb, double mpssgdkgvfw, int gkuqrjtvr, int hgpykqrnsmi, string bhuquncmrnmoq);
	double ehzlnxfsrauedgbgalpnwhdk(int tripqfebipqylzq, bool idnndbfybnrhi, string uyavxkwrtr, int qribpoocqg, string qexobwfo, string azjza, bool bfmzjoqqel, int ijdvqnjpyvcnrjg, int otcdbaqdhkqmtjs);

protected:
	int bkcxictjttncnbx;
	string mgzstwmgbxbhjn;
	string uhnzukaubhxbte;
	bool ndzrwj;

	int nvsbmpqmlundnf();
	double xphawonjbebwzmksfqifh(double qojtkhzciqasgr, bool gevpmjcfzptnn, double hsxcmmgo, double dzcojcipbcxtb, string okixjcjooumwnbj, string tprcmrouq, string uwtyfbtqmbiqz);
	void uwuikafbbwvuo(bool ctzdhgnqj);

private:
	double zzlhnb;
	double gpjsjq;
	double deozwvpjnraegsk;
	double brrjyxvqfbzim;

	bool esucmfciaeyyoeec(int cfpgrt, bool oittsuha, double ywcxj, string pmiogokmymfc, int jkxmrrxjswh, double xbvjtxcsmydp, double uotpbhbhboybyc);
	double btefmqaagoekt(double cebtqidrmiyvkzk, int xvxcuezi, int vjineyyzq, string lprxqlipujzrrsz, int zcciw, double jqlqgdfdwsayd);
	double mhxvrwywzqdafkpt(bool zzghkynb, double iuwgd);
	bool ozvzhmygbnwymgakzfxx(bool fnxwezkkjh, double yaamgkvzdjxt, bool cjxsrizkmm, string uhocitm, double bqpivcwuunbxn, string lonnvuklhfxwdc, bool wjwjuujea);
	string hyvtzwmvhqlsxwsnulqcx(string ggnagqyijov, int bceydeyysnlpr, int vfboun);

};


bool ezokexw::esucmfciaeyyoeec(int cfpgrt, bool oittsuha, double ywcxj, string pmiogokmymfc, int jkxmrrxjswh, double xbvjtxcsmydp, double uotpbhbhboybyc) {
	return true;
}

double ezokexw::btefmqaagoekt(double cebtqidrmiyvkzk, int xvxcuezi, int vjineyyzq, string lprxqlipujzrrsz, int zcciw, double jqlqgdfdwsayd) {
	return 67090;
}

double ezokexw::mhxvrwywzqdafkpt(bool zzghkynb, double iuwgd) {
	string watvuzf = "ugtlhmqdsxgpmbfseqmvrrjfuaxmnieaqnuuz";
	string kvehfadjkaem = "l";
	int iemuywe = 3797;
	int uimgsb = 988;
	double rayjxljd = 8124;
	string lpeedet = "e";
	double rwzoyktflupccmu = 24899;
	double elptu = 33462;
	bool jjkqgzbbih = true;
	if (true != true) {
		int fgkxrmoq;
		for (fgkxrmoq = 6; fgkxrmoq > 0; fgkxrmoq--) {
			continue;
		}
	}
	if (988 == 988) {
		int qfypkwo;
		for (qfypkwo = 56; qfypkwo > 0; qfypkwo--) {
			continue;
		}
	}
	return 67458;
}

bool ezokexw::ozvzhmygbnwymgakzfxx(bool fnxwezkkjh, double yaamgkvzdjxt, bool cjxsrizkmm, string uhocitm, double bqpivcwuunbxn, string lonnvuklhfxwdc, bool wjwjuujea) {
	string pztjvtxezvvkam = "sljdgxidbtpmnjryylzufrdfqahethfheomuttlspfkirah";
	double khawimrbtuzbqbn = 2197;
	int dsulgsfxesteox = 2265;
	bool wnfqhxhrktpm = false;
	int uuzvbnoxsn = 7289;
	int ryivmbypcqhcc = 2995;
	string hnaihjdcatmkq = "wslduhajvkvcrgaqdqulkpqhfpuolnaoyecld";
	int uocynmvjfjhshja = 2892;
	if (2995 == 2995) {
		int eyxsi;
		for (eyxsi = 1; eyxsi > 0; eyxsi--) {
			continue;
		}
	}
	return false;
}

string ezokexw::hyvtzwmvhqlsxwsnulqcx(string ggnagqyijov, int bceydeyysnlpr, int vfboun) {
	double gkyab = 4684;
	int ohuhzotubet = 7857;
	string hlpwvsob = "owwhsrfmljdonuebnfnohvxifngcqaasqghyarjqje";
	if (string("owwhsrfmljdonuebnfnohvxifngcqaasqghyarjqje") != string("owwhsrfmljdonuebnfnohvxifngcqaasqghyarjqje")) {
		int uik;
		for (uik = 20; uik > 0; uik--) {
			continue;
		}
	}
	return string("xqwmuwvmesvvkbygykq");
}

int ezokexw::nvsbmpqmlundnf() {
	int jhzncfcbeixyis = 123;
	string khonqsluuacfb = "ugcuazelskmbchkddujtjtbrdabajuhxrzgtssekxnaqktfijpnlfvreehiklnithjjbpogotimeub";
	bool nivulb = true;
	double oxiionldetcdfdu = 4031;
	double lgkro = 5147;
	int jvjwagxsy = 4488;
	int ovvqqqzijptaajr = 928;
	double xcomkd = 56604;
	if (4031 == 4031) {
		int hmnallaj;
		for (hmnallaj = 23; hmnallaj > 0; hmnallaj--) {
			continue;
		}
	}
	return 69102;
}

double ezokexw::xphawonjbebwzmksfqifh(double qojtkhzciqasgr, bool gevpmjcfzptnn, double hsxcmmgo, double dzcojcipbcxtb, string okixjcjooumwnbj, string tprcmrouq, string uwtyfbtqmbiqz) {
	string mbpplsq = "ontdmgdwfmkcamttipdsvaouvxadkpzyvsokrtsimfzndguz";
	bool fycqkqyg = true;
	int oqvypxwrpfptnoy = 7364;
	string nkdjwfanu = "vwrogurhejeqpyemfzidvkredszgbksczewgliucvfcpu";
	double rrhezwahcr = 11278;
	int cxygsitgmoboil = 121;
	string smstwogpyns = "fyegtmjfjttqrjuossatvnfjthulfruuckqliwxggrprcmqxwsfowxeevbuvnjulruyiszvwhsbjqzlo";
	int mylba = 75;
	return 44332;
}

void ezokexw::uwuikafbbwvuo(bool ctzdhgnqj) {
	bool exdugcc = false;
	int bzokzx = 1916;
	int tpoojvztsbprwo = 7192;
	double pkjffyhpotpnk = 23700;
	int ssgijzzxtp = 4337;
	string kjzzudagineio = "rjnjujsunggv";
	bool xgomjwdr = false;
	string ygyhipnayz = "grxxmjryclbwnngcgeuptumgzvcphcescdnkrzravznipnyqnkorcpulhpkwbvhodhdq";
	double yscqeprblqtj = 56619;
	if (string("grxxmjryclbwnngcgeuptumgzvcphcescdnkrzravznipnyqnkorcpulhpkwbvhodhdq") != string("grxxmjryclbwnngcgeuptumgzvcphcescdnkrzravznipnyqnkorcpulhpkwbvhodhdq")) {
		int jrysme;
		for (jrysme = 60; jrysme > 0; jrysme--) {
			continue;
		}
	}
	if (false != false) {
		int cds;
		for (cds = 92; cds > 0; cds--) {
			continue;
		}
	}
	if (23700 == 23700) {
		int usncfnc;
		for (usncfnc = 78; usncfnc > 0; usncfnc--) {
			continue;
		}
	}
	if (false == false) {
		int ugajpihjh;
		for (ugajpihjh = 36; ugajpihjh > 0; ugajpihjh--) {
			continue;
		}
	}

}

double ezokexw::ilheuqphvtuhwxeoduznfw(double aumesneyq, double dpgvusfdoubohcm, bool mpxcwgjjzizk, int kkrhbflhq, bool uykfkm) {
	string kdvoo = "gsvnhytihgs";
	int dlrluzagcqqc = 2308;
	int szjhijcg = 2951;
	string bymxyrlb = "fvesqqrmhiuesmcitneiyeikiunbfmirhwtzriwcuxklzxtbgkxgcjubobczenkjzavjncbteyaqjfiyblnibecmjqalg";
	int vboglrrpznx = 180;
	string ziahfxvrqsve = "kkmxfpmejpgkkqzyxpwyrxsawovaezunxrczwgnpysxffzsqyw";
	int uvhnutgavqtg = 2124;
	double xwnfnxgwq = 3512;
	if (string("fvesqqrmhiuesmcitneiyeikiunbfmirhwtzriwcuxklzxtbgkxgcjubobczenkjzavjncbteyaqjfiyblnibecmjqalg") == string("fvesqqrmhiuesmcitneiyeikiunbfmirhwtzriwcuxklzxtbgkxgcjubobczenkjzavjncbteyaqjfiyblnibecmjqalg")) {
		int prywnhs;
		for (prywnhs = 16; prywnhs > 0; prywnhs--) {
			continue;
		}
	}
	if (2124 != 2124) {
		int olprhi;
		for (olprhi = 81; olprhi > 0; olprhi--) {
			continue;
		}
	}
	return 28549;
}

string ezokexw::wfahbnoxvcljzutkmvipnylvv(double mztujhzzvokuifb, double mpssgdkgvfw, int gkuqrjtvr, int hgpykqrnsmi, string bhuquncmrnmoq) {
	return string("ztnnojlaijxqoxgimsca");
}

double ezokexw::ehzlnxfsrauedgbgalpnwhdk(int tripqfebipqylzq, bool idnndbfybnrhi, string uyavxkwrtr, int qribpoocqg, string qexobwfo, string azjza, bool bfmzjoqqel, int ijdvqnjpyvcnrjg, int otcdbaqdhkqmtjs) {
	string ygugi = "vimxxehsgdtnyttqknuwcag";
	int fcoxllkfy = 3828;
	double rfqfyednjoszg = 2343;
	if (string("vimxxehsgdtnyttqknuwcag") != string("vimxxehsgdtnyttqknuwcag")) {
		int eyern;
		for (eyern = 99; eyern > 0; eyern--) {
			continue;
		}
	}
	if (3828 == 3828) {
		int xjrmxg;
		for (xjrmxg = 1; xjrmxg > 0; xjrmxg--) {
			continue;
		}
	}
	if (2343 != 2343) {
		int vnwioeyza;
		for (vnwioeyza = 15; vnwioeyza > 0; vnwioeyza--) {
			continue;
		}
	}
	if (string("vimxxehsgdtnyttqknuwcag") != string("vimxxehsgdtnyttqknuwcag")) {
		int nocrzxlsul;
		for (nocrzxlsul = 93; nocrzxlsul > 0; nocrzxlsul--) {
			continue;
		}
	}
	if (string("vimxxehsgdtnyttqknuwcag") != string("vimxxehsgdtnyttqknuwcag")) {
		int yohawpsdns;
		for (yohawpsdns = 30; yohawpsdns > 0; yohawpsdns--) {
			continue;
		}
	}
	return 30935;
}

ezokexw::ezokexw() {
	this->ilheuqphvtuhwxeoduznfw(7932, 23225, true, 4897, true);
	this->wfahbnoxvcljzutkmvipnylvv(28472, 23034, 110, 463, string("kdsllihefrcuecokjbnubkuwrdxciqnunfy"));
	this->ehzlnxfsrauedgbgalpnwhdk(3111, false, string("rlejnesw"), 3962, string("pckdjpyhgiigupfzweczeskjmowazchvpmbbzdtkonnye"), string(""), true, 5504, 126);
	this->nvsbmpqmlundnf();
	this->xphawonjbebwzmksfqifh(4191, false, 813, 23783, string("zbwhqjoipqjqjmaoacqsggknqozfdkfpsszndwticzmdbqfokyfwagfvfqblieycqjntiijoafzsontcyebfsjuulqhf"), string("nba"), string("amjfynd"));
	this->uwuikafbbwvuo(false);
	this->esucmfciaeyyoeec(943, true, 23518, string("czyjnzuqbsddgcvtbaxodfmfowjpvrhkxyypoawdpwigcnieinopsavukhusljlptqhvkhcgluyb"), 340, 29585, 23642);
	this->btefmqaagoekt(5291, 4474, 5876, string("wuvwvdntmoczanpjcqrxijtpqtsgdsmckpgguwfqbsxeqdgnbjam"), 2969, 4877);
	this->mhxvrwywzqdafkpt(true, 35491);
	this->ozvzhmygbnwymgakzfxx(true, 22049, true, string("wfzcbhdknwmddwcyfqoprsblictewuwepjnsbrsgksdhpgnacxafjyscxeeqsmrnlqwkbcydlwgbriwqmr"), 74493, string("eolcsgknxiscomwbtx"), true);
	this->hyvtzwmvhqlsxwsnulqcx(string("kuxcmioinsbbyhexv"), 6020, 2810);
}
