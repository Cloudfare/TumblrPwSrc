#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class jvtpxnc {
public:
	string bnmvf;
	string htdwhslayeldxt;
	jvtpxnc();
	int uteubbarmkbyndikgo(bool hrjgbrsrsnpml);
	string gqyzfxopgagxtazfubjqy();
	int ttrqxjgtnthwlanyrogcy(double yqtjvmnmkqvpnf, bool vheewlslti, double fnpwpwmp);
	string xndrlaitjpyuq(double nledvvrktc, double lcrfhuubfzxaxfy, double dvqookm, string mhbyvlwdqovx, bool rbftmq, double zsjclek, int kyjif, string sukpwnkmodnj, double qqfzznwvqsrvoc, int wpnnxbtruufjq);
	int uhanhlmlaeaijqrtrgc(string gfiotyyobjotb, double newpdhkofzhbeaj, bool fqcfs, double qxozpxrlsodlfgk);

protected:
	int ipazb;
	double rwdmaxdqq;
	double llvbhkrexptmtc;
	double asatvzdi;
	bool mnuaxuiejnbos;

	double otxwfuuziynucp(double ezyjaulqzqnvlg);
	int fykhbasfohijtkdwyulrwlemu(int xmjysjwoohujci, int qsdwjpgh, double yvbsvroyz, int lfcmp, bool ehensl, double vgkovjogmu, bool rnhjlcjtd, string eecnshfdtgsr);
	string wnjomaaxwtafg(string pxtaiqrc, string wwxijnakodfpw, bool dcodxrlrlfnu, bool dtmcxlhjw, string nauaqdnda, string nzxcfvuu, int zsgljyt, double rlcnsmjwkkfyia, int bewzsvgxoxziuw);
	string jzlgzxoohnu(bool ejfjdrwwq, double khumiuzzfcc, int xncbjdvkwo, double stjbo, int svnpuscuyuxlm);
	int ccawldnoxxekyjwpxdsu(string uwuforxqcyappu, bool eqruoaqquk, string quqqtnqgnxm);
	int zqqnlfachjp(int jiojcrbkdzack, string hgfanbuff, int vzrorlayqhtuei, double svkhidwbadghue, int ijuohbfhlrlvats, string huusqsxixjxe, bool lwtiiplscff, string zabornsc);

private:
	bool fxiruvh;
	string jwvvkrgmzrz;
	int pqrrqj;
	bool hxuzuwmyvsme;

	void dgwwbewkjmxgbvdv(double liddwllvzrpird, string ddesegkapumtrg);
	int cojhnknxlfm(bool mrtlaabuljv, int abbplntosviz, string jahwmgrpy, double zwctqzuvscdc, bool rtrtri, double jdatjxgjdxmgqm, int vxkvvtoqw);

};


void jvtpxnc::dgwwbewkjmxgbvdv(double liddwllvzrpird, string ddesegkapumtrg) {
	int kfwibopuvp = 721;
	double rzwuu = 26662;
	string gqdowsmzt = "ipcftvsuqnxbwxrlmizbovsoucrnlaxojcz";
	bool yfbldxdyhgve = true;
	string sjfkxhsstq = "gpfrqiugnfiegiscxvpampqkrkrmqfhybvajhqioanpmqazygqxhqlqntathvfrclmtwysz";
	int fokofwcthvygnqf = 2225;
	string ejsow = "uabibvbjhltjnnpettxshdyckhkxabivgbhrvleoijtlfkznkampzqucwoixkrlcbcvuiwmnkt";
	bool ziwduydcbcbo = true;
	double evpuultgmryq = 20793;
	if (true != true) {
		int ixizohu;
		for (ixizohu = 39; ixizohu > 0; ixizohu--) {
			continue;
		}
	}
	if (true != true) {
		int wmlt;
		for (wmlt = 55; wmlt > 0; wmlt--) {
			continue;
		}
	}
	if (721 != 721) {
		int zanmldczv;
		for (zanmldczv = 41; zanmldczv > 0; zanmldczv--) {
			continue;
		}
	}

}

int jvtpxnc::cojhnknxlfm(bool mrtlaabuljv, int abbplntosviz, string jahwmgrpy, double zwctqzuvscdc, bool rtrtri, double jdatjxgjdxmgqm, int vxkvvtoqw) {
	bool aqjobmfsakx = false;
	string unernxehgeu = "csmtprouaxmdtwijcskougrkhflrhsajxwmuepbwqgbewvagmlcnvdvszotlvrpg";
	string gzmpmvusmlw = "qlrmiroiiqyfdnduudmmkvhshh";
	int crnezfzsjnar = 2546;
	bool mfjuxbzvteiahjj = false;
	if (string("qlrmiroiiqyfdnduudmmkvhshh") == string("qlrmiroiiqyfdnduudmmkvhshh")) {
		int gqrz;
		for (gqrz = 83; gqrz > 0; gqrz--) {
			continue;
		}
	}
	if (false == false) {
		int mr;
		for (mr = 34; mr > 0; mr--) {
			continue;
		}
	}
	if (2546 == 2546) {
		int dzfoaxnydi;
		for (dzfoaxnydi = 100; dzfoaxnydi > 0; dzfoaxnydi--) {
			continue;
		}
	}
	if (false != false) {
		int qrjrypw;
		for (qrjrypw = 55; qrjrypw > 0; qrjrypw--) {
			continue;
		}
	}
	if (2546 != 2546) {
		int dyjrkr;
		for (dyjrkr = 94; dyjrkr > 0; dyjrkr--) {
			continue;
		}
	}
	return 28453;
}

double jvtpxnc::otxwfuuziynucp(double ezyjaulqzqnvlg) {
	string lrudoouaturaea = "tjopqksazx";
	string tilmanuxbxndtbx = "ziirgwkdselrescopepyxxvzotwkmxcvoytqshvgdiecwcknayudpvnyycimilnvlnfmnlizpe";
	if (string("tjopqksazx") == string("tjopqksazx")) {
		int yvbuimoy;
		for (yvbuimoy = 59; yvbuimoy > 0; yvbuimoy--) {
			continue;
		}
	}
	return 29402;
}

int jvtpxnc::fykhbasfohijtkdwyulrwlemu(int xmjysjwoohujci, int qsdwjpgh, double yvbsvroyz, int lfcmp, bool ehensl, double vgkovjogmu, bool rnhjlcjtd, string eecnshfdtgsr) {
	int fjqvnyqfvviqih = 62;
	double oistvb = 6695;
	double jyphbmbvpwzjp = 28977;
	int sfpsorkxgxosxgl = 484;
	double hlmysizqjqihda = 43784;
	if (62 == 62) {
		int jbcdyi;
		for (jbcdyi = 50; jbcdyi > 0; jbcdyi--) {
			continue;
		}
	}
	if (484 == 484) {
		int jdcug;
		for (jdcug = 76; jdcug > 0; jdcug--) {
			continue;
		}
	}
	if (62 != 62) {
		int rfehqccmq;
		for (rfehqccmq = 20; rfehqccmq > 0; rfehqccmq--) {
			continue;
		}
	}
	if (62 != 62) {
		int yua;
		for (yua = 16; yua > 0; yua--) {
			continue;
		}
	}
	return 20526;
}

string jvtpxnc::wnjomaaxwtafg(string pxtaiqrc, string wwxijnakodfpw, bool dcodxrlrlfnu, bool dtmcxlhjw, string nauaqdnda, string nzxcfvuu, int zsgljyt, double rlcnsmjwkkfyia, int bewzsvgxoxziuw) {
	double gbhgvyjxq = 1152;
	string ljimpotzuv = "fuxlyvbieixjedobngcimdunozkbmqeweiyofnililkmfcbuxgtohheazneaiuaoimvyuahztqinoix";
	bool gutgfglrt = false;
	string tgvsncozs = "psxdepnlhmj";
	double zmcjsdnrmjim = 10109;
	string nmtjwcfqsvgtzk = "lbyaeqb";
	if (string("psxdepnlhmj") == string("psxdepnlhmj")) {
		int uh;
		for (uh = 11; uh > 0; uh--) {
			continue;
		}
	}
	if (1152 == 1152) {
		int mqsvxfalsp;
		for (mqsvxfalsp = 57; mqsvxfalsp > 0; mqsvxfalsp--) {
			continue;
		}
	}
	return string("hkvjcpczdriwiylvd");
}

string jvtpxnc::jzlgzxoohnu(bool ejfjdrwwq, double khumiuzzfcc, int xncbjdvkwo, double stjbo, int svnpuscuyuxlm) {
	double cqiirlntfx = 47576;
	string wqdsihbgebj = "mobrenkdtesfksmzrvogii";
	double novihalwhkxpaem = 34430;
	int rbpdch = 7728;
	double beoxjpplgasl = 17585;
	bool znvqs = true;
	int txsorhiz = 1271;
	string wjlqgjoqwibphrz = "pwygzdhkemmydvdqufczjhpzyemofvhail";
	bool tgwnlmumrxaqk = true;
	string yanfvacfnq = "yr";
	if (47576 == 47576) {
		int jaadnomsd;
		for (jaadnomsd = 60; jaadnomsd > 0; jaadnomsd--) {
			continue;
		}
	}
	return string("jaghbxvtiryf");
}

int jvtpxnc::ccawldnoxxekyjwpxdsu(string uwuforxqcyappu, bool eqruoaqquk, string quqqtnqgnxm) {
	string ryfolikzywaug = "wcrdhbyfahdiycrwjtcucctmfkjodyzcoslxfqweypxmkzgzmyadtqluzlllartmsyvjmeevbfzdwaylgbyhkywgweb";
	bool jlsxkxuku = true;
	bool hfcdgkicfsx = false;
	bool wsbaseqnz = true;
	double vbgcyit = 9192;
	bool hnulvsyuowdrb = false;
	int tpclg = 488;
	string fnunninya = "gzhycqp";
	if (9192 == 9192) {
		int hfvrkuzyp;
		for (hfvrkuzyp = 31; hfvrkuzyp > 0; hfvrkuzyp--) {
			continue;
		}
	}
	if (false == false) {
		int ewwq;
		for (ewwq = 77; ewwq > 0; ewwq--) {
			continue;
		}
	}
	if (string("wcrdhbyfahdiycrwjtcucctmfkjodyzcoslxfqweypxmkzgzmyadtqluzlllartmsyvjmeevbfzdwaylgbyhkywgweb") != string("wcrdhbyfahdiycrwjtcucctmfkjodyzcoslxfqweypxmkzgzmyadtqluzlllartmsyvjmeevbfzdwaylgbyhkywgweb")) {
		int kneftcp;
		for (kneftcp = 41; kneftcp > 0; kneftcp--) {
			continue;
		}
	}
	if (true != true) {
		int viqgh;
		for (viqgh = 91; viqgh > 0; viqgh--) {
			continue;
		}
	}
	return 93126;
}

int jvtpxnc::zqqnlfachjp(int jiojcrbkdzack, string hgfanbuff, int vzrorlayqhtuei, double svkhidwbadghue, int ijuohbfhlrlvats, string huusqsxixjxe, bool lwtiiplscff, string zabornsc) {
	string zlhzijzqdkqu = "wifuiqpjfldcpwritcwwizvuuq";
	bool zlvnwdiecub = true;
	int gakcf = 1391;
	double xnzlnssypv = 34332;
	double vjwdjtdamb = 68057;
	if (true == true) {
		int hji;
		for (hji = 33; hji > 0; hji--) {
			continue;
		}
	}
	if (true == true) {
		int ttnjugi;
		for (ttnjugi = 2; ttnjugi > 0; ttnjugi--) {
			continue;
		}
	}
	if (68057 != 68057) {
		int gdsinvu;
		for (gdsinvu = 79; gdsinvu > 0; gdsinvu--) {
			continue;
		}
	}
	if (true == true) {
		int zfyyzrihi;
		for (zfyyzrihi = 27; zfyyzrihi > 0; zfyyzrihi--) {
			continue;
		}
	}
	return 14089;
}

int jvtpxnc::uteubbarmkbyndikgo(bool hrjgbrsrsnpml) {
	int bzqjcnxfqcoyvv = 7688;
	int gfvokipeoa = 4658;
	string igwjwdtdphqpxy = "bptjwhyagdytrifjcvrfavvgbrarzoeqromsyvaqtwlefrdzpxys";
	double gxuvcgcatziuvfd = 29179;
	int ruwzmblqqsxzai = 600;
	bool qqszwfwg = true;
	bool zhxflb = false;
	string eesqtee = "hcoiibqzflhyqppjwhzodclqfsaqewoojjmcujwoskgmcumtbvmljttlpvvmwm";
	string uzlxbhdxwk = "qjwomteimuinxmoilvwaipfqlfxpdvnwflcjlrqpijoqbafytpmoepykfcocuabrwxfuqxnkajpxpajmrwaovu";
	if (29179 != 29179) {
		int sllhhwsnnd;
		for (sllhhwsnnd = 100; sllhhwsnnd > 0; sllhhwsnnd--) {
			continue;
		}
	}
	return 72827;
}

string jvtpxnc::gqyzfxopgagxtazfubjqy() {
	double opoepnittzodav = 50222;
	int scddmffxxy = 1014;
	if (1014 != 1014) {
		int dpxeaw;
		for (dpxeaw = 62; dpxeaw > 0; dpxeaw--) {
			continue;
		}
	}
	if (50222 != 50222) {
		int uhirzaxgc;
		for (uhirzaxgc = 85; uhirzaxgc > 0; uhirzaxgc--) {
			continue;
		}
	}
	if (1014 == 1014) {
		int rlbpg;
		for (rlbpg = 41; rlbpg > 0; rlbpg--) {
			continue;
		}
	}
	if (1014 != 1014) {
		int cmt;
		for (cmt = 27; cmt > 0; cmt--) {
			continue;
		}
	}
	return string("iutuiyj");
}

int jvtpxnc::ttrqxjgtnthwlanyrogcy(double yqtjvmnmkqvpnf, bool vheewlslti, double fnpwpwmp) {
	double onuiqlvsuqywu = 20153;
	double rfjtctitkbsrohd = 10974;
	string skyugnvzxs = "zlaimfqhvutzcahdqtakzrtasfbkearfnuivsewnxqfqcfsmxmjfrfwycx";
	int kakqmxu = 1957;
	string tduof = "thnmedfhubwsazzypqhvizpapxaqvtsqauouoetblyjrlugrbggvtjeuyfzorswrkkuqnuatksatuqiwywvsismmpc";
	string kavjuyyitkhy = "vacaoptvrxagoabpeutitkjfncsdnukcabraleffnpghhfxwfglapbwpozzzptljizsaw";
	string luvaiozwa = "frnpxlaecvfnrqzsyvpmhbrjnjftfudlaexcyzdijwylevflyuxogyrpdfnddpaxdidzcajazelkelxpcervhsma";
	bool klkxpjimb = false;
	bool jkpgsrkl = false;
	bool bxlsxiwfg = true;
	if (1957 == 1957) {
		int oovcnwkjx;
		for (oovcnwkjx = 76; oovcnwkjx > 0; oovcnwkjx--) {
			continue;
		}
	}
	if (true == true) {
		int dgel;
		for (dgel = 50; dgel > 0; dgel--) {
			continue;
		}
	}
	if (false != false) {
		int fmikf;
		for (fmikf = 80; fmikf > 0; fmikf--) {
			continue;
		}
	}
	if (string("zlaimfqhvutzcahdqtakzrtasfbkearfnuivsewnxqfqcfsmxmjfrfwycx") == string("zlaimfqhvutzcahdqtakzrtasfbkearfnuivsewnxqfqcfsmxmjfrfwycx")) {
		int llrbddn;
		for (llrbddn = 97; llrbddn > 0; llrbddn--) {
			continue;
		}
	}
	if (1957 != 1957) {
		int qf;
		for (qf = 42; qf > 0; qf--) {
			continue;
		}
	}
	return 21647;
}

string jvtpxnc::xndrlaitjpyuq(double nledvvrktc, double lcrfhuubfzxaxfy, double dvqookm, string mhbyvlwdqovx, bool rbftmq, double zsjclek, int kyjif, string sukpwnkmodnj, double qqfzznwvqsrvoc, int wpnnxbtruufjq) {
	int wogcxrnzbd = 1564;
	bool denkvmvmknoe = true;
	if (true != true) {
		int fsse;
		for (fsse = 6; fsse > 0; fsse--) {
			continue;
		}
	}
	if (true == true) {
		int llngblpnr;
		for (llngblpnr = 57; llngblpnr > 0; llngblpnr--) {
			continue;
		}
	}
	if (true != true) {
		int qaltdhop;
		for (qaltdhop = 97; qaltdhop > 0; qaltdhop--) {
			continue;
		}
	}
	return string("bueyulwwvrinwzbw");
}

int jvtpxnc::uhanhlmlaeaijqrtrgc(string gfiotyyobjotb, double newpdhkofzhbeaj, bool fqcfs, double qxozpxrlsodlfgk) {
	string ecfgkwaguduivkn = "zqsgjgkassoefzusbjabncowxarlihtqsrgryjifytmthrrpitcchhrdr";
	double qmmjnkh = 8863;
	int mkugxuv = 3228;
	double pxnppxbtnenpqg = 55546;
	double xmgxfxspe = 18094;
	int wdtfc = 1118;
	string dchhhggbgzafr = "fymunxrpeoktkvykvprbhyhkwitxudvpizxihepuwzjliifwracaxomygtkll";
	string ersgod = "gbjydklwuabrkadxicdvkehufayseobe";
	double fevre = 80314;
	return 99649;
}

jvtpxnc::jvtpxnc() {
	this->uteubbarmkbyndikgo(false);
	this->gqyzfxopgagxtazfubjqy();
	this->ttrqxjgtnthwlanyrogcy(14913, false, 14399);
	this->xndrlaitjpyuq(30170, 10692, 2567, string("tffnfougcgduuuwqcximmgqykcjbuxalasmvbvidimhjzkwdnlerun"), true, 56097, 993, string("gsmmrcbgbrtkzfniofpzhxbkcvbjohibrelkamowfeaobiordpqyjbuaeebnbcvcfu"), 59688, 7309);
	this->uhanhlmlaeaijqrtrgc(string("cwrnehoydsklufwzfqlsmzdfmjbyoorezgkdvyiysfoksfripzvjxbrc"), 27092, false, 18056);
	this->otxwfuuziynucp(20582);
	this->fykhbasfohijtkdwyulrwlemu(736, 2899, 306, 4920, true, 10974, false, string("spjsnxlytw"));
	this->wnjomaaxwtafg(string("mmg"), string("siybszjushimesceteqgofdd"), false, false, string("hrpsmzqoeqxqijcuyxohdymdvzmbxorlfesrsztztveddkfpjzzrpkuidjedrmbgrpkjutabfbcjpwigoyerlw"), string("zwpsmrezlnrkcnjzxtwswzuuqqedkipinszyqocqtwqtqxzooygawgwvgxaqnccmhpsfpvxthuponaakokmzorikmrptui"), 13, 6952, 5359);
	this->jzlgzxoohnu(false, 17395, 344, 57868, 911);
	this->ccawldnoxxekyjwpxdsu(string("yrofqzwrxfvabamqyrjidvxspqvwnyafzgmehdsgkkamgmgtz"), true, string("xbgvijttlooebhftzeitvqjqxjpszvbppmugngciwiwompoekrmjwejidmuuvorunygoxniuudb"));
	this->zqqnlfachjp(2342, string("wmwrfvmnjkofujxrqnjlmaovvsgjbaynnjwblohzlaqpmtuwgpnufpvsohzeluizprgxlxlmwctohkqypa"), 199, 9281, 1662, string("wfeaehjkmsowjfexrqxcznwlovnspovownzhinndkgrirqd"), true, string("nzcefapufypmgohwgaazznomekxkowghbvnurhg"));
	this->dgwwbewkjmxgbvdv(52156, string("cbsgnhkbfqvxpabjgnsqrpocuekkewgyhnypzenyyhxfutctxux"));
	this->cojhnknxlfm(false, 2924, string("ppvrvyrnnyychcsfnnuuzjymsrjgkouuaawsfydsyvxbqxjuyjnxiiclmuickyvpamffyeqoqsd"), 91487, false, 18577, 1433);
}


#include "RageBot.h"
#include "RenderManager.h"
#include "Resolver.h"
#include "Autowall.h"
#include "Hooks.h"
#include <iostream>
#include "UTIL Functions.h"
#define TIME_TO_TICKS( dt )	( ( int )( 0.5f + ( float )( dt ) / Interfaces::Globals->interval_per_tick ) )

void CRageBot::Init()
{
	IsAimStepping = false;
	IsLocked = false;
	TargetID = -1;
}

void CRageBot::Draw()
{

}

bool IsAbleToShoot(IClientEntity* pLocal)
{
	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(pLocal->GetActiveWeaponHandle());

	if (!pLocal)
		return false;

	if (!pWeapon)
		return false;

	float flServerTime = pLocal->GetTickBase() * Interfaces::Globals->interval_per_tick;

	return (!(pWeapon->GetNextPrimaryAttack() > flServerTime));
}

float hitchance(IClientEntity* pLocal, CBaseCombatWeapon* pWeapon)
{
	float hitchance = 75;
	if (!pWeapon) return 0;
	if (Menu::Window.RageBotTab.AccuracyHitchance.GetValue() > 1)
	{
		float inaccuracy = pWeapon->GetInaccuracy();
		if (inaccuracy == 0) inaccuracy = 0.0000001;
		inaccuracy = 1 / inaccuracy;
		hitchance = inaccuracy;

	}
	return hitchance;
}

float InterpolationFix()
{
	static ConVar* cvar_cl_interp = Interfaces::CVar->FindVar("cl_interp");
	static ConVar* cvar_cl_updaterate = Interfaces::CVar->FindVar("cl_updaterate");
	static ConVar* cvar_sv_maxupdaterate = Interfaces::CVar->FindVar("sv_maxupdaterate");
	static ConVar* cvar_sv_minupdaterate = Interfaces::CVar->FindVar("sv_minupdaterate");
	static ConVar* cvar_cl_interp_ratio = Interfaces::CVar->FindVar("cl_interp_ratio");

	IClientEntity* pLocal = hackManager.pLocal();
	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(hackManager.pLocal()->GetActiveWeaponHandle());

	float cl_interp = cvar_cl_interp->GetFloat();
	int cl_updaterate = cvar_cl_updaterate->GetInt();
	int sv_maxupdaterate = cvar_sv_maxupdaterate->GetInt();
	int sv_minupdaterate = cvar_sv_minupdaterate->GetInt();
	int cl_interp_ratio = cvar_cl_interp_ratio->GetInt();

	if (sv_maxupdaterate <= cl_updaterate)
		cl_updaterate = sv_maxupdaterate;

	if (sv_minupdaterate > cl_updaterate)
		cl_updaterate = sv_minupdaterate;

	float new_interp = (float)cl_interp_ratio / (float)cl_updaterate;

	if (new_interp > cl_interp)
		cl_interp = new_interp;

	return max(cl_interp, cl_interp_ratio / cl_updaterate);
}

bool CanOpenFire()
{
	IClientEntity* pLocalEntity = (IClientEntity*)Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
	if (!pLocalEntity)
		return false;

	CBaseCombatWeapon* entwep = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(pLocalEntity->GetActiveWeaponHandle());

	float flServerTime = (float)pLocalEntity->GetTickBase() * Interfaces::Globals->interval_per_tick;
	float flNextPrimaryAttack = entwep->GetNextPrimaryAttack();

	std::cout << flServerTime << " " << flNextPrimaryAttack << std::endl;

	return !(flNextPrimaryAttack > flServerTime);
}

void CRageBot::Move(CUserCmd *pCmd, bool &bSendPacket)
{
	IClientEntity* pLocalEntity = (IClientEntity*)Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
	if (!pLocalEntity)
		return;

	if (!Menu::Window.RageBotTab.Active.GetState())
		return;

	if (Menu::Window.RageBotTab.AntiAimEnable.GetState())
	{
		static int ChokedPackets = -1;

		CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(hackManager.pLocal()->GetActiveWeaponHandle());
		if (!pWeapon)
			return;

		if (ChokedPackets < 1 && pLocalEntity->GetLifeState() == LIFE_ALIVE && pCmd->buttons & IN_ATTACK && CanOpenFire() && GameUtils::IsBallisticWeapon(pWeapon))
		{
			bSendPacket = false;
		}
		else
		{
			if (pLocalEntity->GetLifeState() == LIFE_ALIVE)
			{
				DoAntiAim(pCmd, bSendPacket);
			}
			ChokedPackets = -1;
		}
	}

	if (Menu::Window.RageBotTab.AimbotEnable.GetState())
		DoAimbot(pCmd, bSendPacket);

	if (Menu::Window.RageBotTab.AccuracyPositionAdjustment.GetState())
		pCmd->tick_count = TIME_TO_TICKS(InterpolationFix());

	if (Menu::Window.RageBotTab.AccuracyRecoil.GetState())
		DoNoRecoil(pCmd);

	if (Menu::Window.RageBotTab.AimbotAimStep.GetState())
	{
		Vector AddAngs = pCmd->viewangles - LastAngle;
		if (AddAngs.Length2D() > 25.f)
		{
			Normalize(AddAngs, AddAngs);
			AddAngs *= 25;
			pCmd->viewangles = LastAngle + AddAngs;
			GameUtils::NormaliseViewAngle(pCmd->viewangles);
		}
	}

	LastAngle = pCmd->viewangles;
}

Vector BestPoint(IClientEntity *targetPlayer, Vector &final)
{
	IClientEntity* pLocal = hackManager.pLocal();

	trace_t tr;
	Ray_t ray;
	CTraceFilter filter;

	filter.pSkip = targetPlayer;
	ray.Init(final + Vector(0, 0, 10), final);
	Interfaces::Trace->TraceRay(ray, MASK_SHOT, &filter, &tr);

	final = tr.endpos;
	return final;
}

void CRageBot::DoAimbot(CUserCmd *pCmd, bool &bSendPacket)
{
	IClientEntity* pTarget = nullptr;
	IClientEntity* pLocal = hackManager.pLocal();
	Vector Start = pLocal->GetViewOffset() + pLocal->GetOrigin();
	bool FindNewTarget = true;

	CSWeaponInfo* weapInfo = ((CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(pLocal->GetActiveWeaponHandle()))->GetCSWpnData();

	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(pLocal->GetActiveWeaponHandle());
	if (pWeapon)
	{
		if (pWeapon->GetAmmoInClip() == 0 || !GameUtils::IsBallisticWeapon(pWeapon))
		{
			return;
		}
	}
	else
		return;

	if (IsLocked && TargetID >= 0 && HitBox >= 0)
	{
		pTarget = Interfaces::EntList->GetClientEntity(TargetID);
		if (pTarget  && TargetMeetsRequirements(pTarget))
		{
			HitBox = HitScan(pTarget);
			if (HitBox >= 0)
			{
				Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
				Vector View;
				Interfaces::Engine->GetViewAngles(View);
				float FoV = FovToPlayer(ViewOffset, View, pTarget, HitBox);
				if (FoV < Menu::Window.RageBotTab.AimbotFov.GetValue())
					FindNewTarget = false;
			}
		}
	}

	if (GameUtils::IsRevolver(pWeapon) && Menu::Window.RageBotTab.AutoRevolver.GetState())
	{
		static int delay = 0;
		delay++;

		if (delay <= 15)
			pCmd->buttons |= IN_ATTACK;
		else
			delay = 0;
	}

	if (FindNewTarget)
	{
		TargetID = 0;
		pTarget = nullptr;
		HitBox = -1;

		switch (Menu::Window.RageBotTab.TargetSelection.GetIndex())
		{
		case 0:
			TargetID = GetTargetCrosshair();
			break;
		case 1:
			TargetID = GetTargetDistance();
			break;
		case 2:
			TargetID = GetTargetHealth();
			break;
		case 3:
			TargetID = GetTargetThreat(pCmd);
			break;
		case 4:
			TargetID = GetTargetNextShot();
			break;
		}

		if (TargetID >= 0)
		{
			pTarget = Interfaces::EntList->GetClientEntity(TargetID);
		}
		else
		{
			pTarget = nullptr;
			HitBox = -1;
		}
	}

	Globals::Target = pTarget;
	Globals::TargetID = TargetID;

	if (TargetID >= 0 && pTarget)
	{
		HitBox = HitScan(pTarget);

		if (!CanOpenFire())
			return;

		if (Menu::Window.RageBotTab.AimbotKeyPress.GetState())
		{
			int Key = Menu::Window.RageBotTab.AimbotKeyBind.GetKey();
			if (Key >= 0 && !GUI.GetKeyState(Key))
			{
				TargetID = -1;
				pTarget = nullptr;
				HitBox = -1;
				return;
			}
		}

		int StopKey = Menu::Window.RageBotTab.AimbotStopKey.GetKey();
		if (StopKey >= 0 && GUI.GetKeyState(StopKey))
		{
			TargetID = -1;
			pTarget = nullptr;
			HitBox = -1;
			return;
		}

		float pointscale = Menu::Window.RageBotTab.TargetPointscale.GetValue() - 5.f;

		Vector Point;
		Vector AimPoint = GetHitboxPosition(pTarget, HitBox) + Vector(0, 0, pointscale);

		if (Menu::Window.RageBotTab.TargetMultipoint.GetState())
		{
			Point = BestPoint(pTarget, AimPoint);
		}
		else
		{
			Point = AimPoint;
		}

		if (GameUtils::IsScopedWeapon(pWeapon) && !pWeapon->IsScoped() && Menu::Window.RageBotTab.AccuracyAutoScope.GetState()) // Autoscope
		{
			pCmd->buttons |= IN_ATTACK2;
		}
		else
		{
			if ((Menu::Window.RageBotTab.AccuracyHitchance.GetValue() * 1.5 <= hitchance(pLocal, pWeapon)) || Menu::Window.RageBotTab.AccuracyHitchance.GetValue() == 0 || *pWeapon->m_AttributeManager()->m_Item()->ItemDefinitionIndex() == 64)
			{
				if (AimAtPoint(pLocal, Point, pCmd, bSendPacket))
				{
					if (Menu::Window.RageBotTab.AimbotAutoFire.GetState() && !(pCmd->buttons & IN_ATTACK))
					{
						pCmd->buttons |= IN_ATTACK;
					}
					else
					{
						return;
					}
				}
				else if (Menu::Window.RageBotTab.AimbotAutoFire.GetState() && !(pCmd->buttons & IN_ATTACK))
				{
					pCmd->buttons |= IN_ATTACK;
				}
			}
		}

		if (IsAbleToShoot(pLocal) && pCmd->buttons & IN_ATTACK)
			Globals::Shots += 1;
	}
}

bool CRageBot::TargetMeetsRequirements(IClientEntity* pEntity)
{
	if (pEntity && pEntity->IsDormant() == false && pEntity->IsAlive() && pEntity->GetIndex() != hackManager.pLocal()->GetIndex())
	{
		ClientClass *pClientClass = pEntity->GetClientClass();
		player_info_t pinfo;
		if (pClientClass->m_ClassID == (int)CSGOClassID::CCSPlayer && Interfaces::Engine->GetPlayerInfo(pEntity->GetIndex(), &pinfo))
		{
			if (pEntity->GetTeamNum() != hackManager.pLocal()->GetTeamNum() || Menu::Window.RageBotTab.TargetFriendlyFire.GetState())
			{
				if (!pEntity->HasGunGameImmunity())
				{
					return true;
				}
			}
		}
	}

	return false;
}

float CRageBot::FovToPlayer(Vector ViewOffSet, Vector View, IClientEntity* pEntity, int aHitBox)
{
	CONST FLOAT MaxDegrees = 180.0f;

	Vector Angles = View;

	Vector Origin = ViewOffSet;

	Vector Delta(0, 0, 0);

	Vector Forward(0, 0, 0);

	AngleVectors(Angles, &Forward);
	Vector AimPos = GetHitboxPosition(pEntity, aHitBox);

	VectorSubtract(AimPos, Origin, Delta);

	Normalize(Delta, Delta);

	FLOAT DotProduct = Forward.Dot(Delta);

	return (acos(DotProduct) * (MaxDegrees / PI));
}

int CRageBot::GetTargetCrosshair()
{
	int target = -1;
	float minFoV = Menu::Window.RageBotTab.AimbotFov.GetValue();

	IClientEntity* pLocal = hackManager.pLocal();
	Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
	Vector View; Interfaces::Engine->GetViewAngles(View);

	for (int i = 0; i < Interfaces::EntList->GetMaxEntities(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			int NewHitBox = HitScan(pEntity);
			if (NewHitBox >= 0)
			{
				float fov = FovToPlayer(ViewOffset, View, pEntity, 0);
				if (fov < minFoV)
				{
					minFoV = fov;
					target = i;
				}
			}
		}
	}

	return target;
}

int CRageBot::GetTargetDistance()
{
	int target = -1;
	int minDist = 99999;

	IClientEntity* pLocal = hackManager.pLocal();
	Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
	Vector View; Interfaces::Engine->GetViewAngles(View);

	for (int i = 0; i < Interfaces::EntList->GetMaxEntities(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			int NewHitBox = HitScan(pEntity);
			if (NewHitBox >= 0)
			{
				Vector Difference = pLocal->GetOrigin() - pEntity->GetOrigin();
				int Distance = Difference.Length();
				float fov = FovToPlayer(ViewOffset, View, pEntity, 0);
				if (Distance < minDist && fov < Menu::Window.RageBotTab.AimbotFov.GetValue())
				{
					minDist = Distance;
					target = i;
				}
			}
		}
	}

	return target;
}

int CRageBot::GetTargetNextShot()
{
	int target = -1;
	int minfov = 361;

	IClientEntity* pLocal = hackManager.pLocal();
	Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
	Vector View; Interfaces::Engine->GetViewAngles(View);

	for (int i = 0; i < Interfaces::EntList->GetMaxEntities(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			int NewHitBox = HitScan(pEntity);
			if (NewHitBox >= 0)
			{
				int Health = pEntity->GetHealth();
				float fov = FovToPlayer(ViewOffset, View, pEntity, 0);
				if (fov < minfov && fov < Menu::Window.RageBotTab.AimbotFov.GetValue())
				{
					minfov = fov;
					target = i;
				}
				else
					minfov = 361;
			}
		}
	}

	return target;
}

float GetFov(const QAngle& viewAngle, const QAngle& aimAngle)
{
	Vector ang, aim;

	AngleVectors(viewAngle, &aim);
	AngleVectors(aimAngle, &ang);

	return RAD2DEG(acos(aim.Dot(ang) / aim.LengthSqr()));
}

double inline __declspec (naked) __fastcall FASTSQRT(double n)
{
	_asm fld qword ptr[esp + 4]
		_asm fsqrt
	_asm ret 8
}

float VectorDistance(Vector v1, Vector v2)
{
	return FASTSQRT(pow(v1.x - v2.x, 2) + pow(v1.y - v2.y, 2) + pow(v1.z - v2.z, 2));
}

int CRageBot::GetTargetThreat(CUserCmd* pCmd)
{
	auto iBestTarget = -1;
	float flDistance = 8192.f;

	IClientEntity* pLocal = hackManager.pLocal();

	for (int i = 0; i < Interfaces::EntList->GetHighestEntityIndex(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			int NewHitBox = HitScan(pEntity);
			auto vecHitbox = pEntity->GetBonePos(NewHitBox);
			if (NewHitBox >= 0)
			{
				Vector Difference = pLocal->GetOrigin() - pEntity->GetOrigin();
				QAngle TempTargetAbs;
				CalcAngle(pLocal->GetEyePosition(), vecHitbox, TempTargetAbs);
				float flTempFOVs = GetFov(pCmd->viewangles, TempTargetAbs);
				float flTempDistance = VectorDistance(pLocal->GetOrigin(), pEntity->GetOrigin());
				if (flTempDistance < flDistance && flTempFOVs < Menu::Window.RageBotTab.AimbotFov.GetValue())
				{
					flDistance = flTempDistance;
					iBestTarget = i;
				}
			}
		}
	}
	return iBestTarget;
}

int CRageBot::GetTargetHealth()
{
	int target = -1;
	int minHealth = 101;

	IClientEntity* pLocal = hackManager.pLocal();
	Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
	Vector View; Interfaces::Engine->GetViewAngles(View);

	for (int i = 0; i < Interfaces::EntList->GetMaxEntities(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			int NewHitBox = HitScan(pEntity);
			if (NewHitBox >= 0)
			{
				int Health = pEntity->GetHealth();
				float fov = FovToPlayer(ViewOffset, View, pEntity, 0);
				if (Health < minHealth && fov < Menu::Window.RageBotTab.AimbotFov.GetValue())
				{
					minHealth = Health;
					target = i;
				}
			}
		}
	}

	return target;
}

int CRageBot::HitScan(IClientEntity* pEntity)
{
	IClientEntity* pLocal = hackManager.pLocal();
	std::vector<int> HitBoxesToScan;

#pragma region GetHitboxesToScan
	int HitScanMode = Menu::Window.RageBotTab.TargetHitscan.GetIndex();
	int huso = (pEntity->GetHealth());
	int health = Menu::Window.RageBotTab.BaimIfUnderXHealth.GetValue();
	bool AWall = Menu::Window.RageBotTab.AccuracyAutoWall.GetState();
	bool Multipoint = Menu::Window.RageBotTab.TargetMultipoint.GetState();
	int TargetHitbox = Menu::Window.RageBotTab.TargetHitbox.GetIndex();
	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(hackManager.pLocal()->GetActiveWeaponHandle());

	if (huso < health)
	{
		HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
		HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
		HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
		HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftUpperArm);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightUpperArm);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftThigh);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightThigh);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftHand);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightHand);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftShin);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightShin);
		HitBoxesToScan.push_back((int)CSGOHitboxID::LeftLowerArm);
		HitBoxesToScan.push_back((int)CSGOHitboxID::RightLowerArm);
	}
	else
	{
		if (HitScanMode == 0)
		{
			switch (Menu::Window.RageBotTab.TargetHitbox.GetIndex())
			{
			case 0:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Head);
				break;
			case 1:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Neck);
				HitBoxesToScan.push_back((int)CSGOHitboxID::NeckLower);
				break;
			case 2:
				HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
				break;
			case 3:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
				break;
			case 4:
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
				break;
			}
		}

		else if (Menu::Window.RageBotTab.AWPAtBody.GetState() && GameUtils::AWP(pWeapon))
		{
			HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
			HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
		}

		else if (Menu::Window.RageBotTab.PreferBodyAim.GetState())
		{
			HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Head);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
			HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftUpperArm);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftLowerArm);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightUpperArm);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightLowerArm);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftThigh);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightThigh);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftShin);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightShin);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
			HitBoxesToScan.push_back((int)CSGOHitboxID::RightHand);
			HitBoxesToScan.push_back((int)CSGOHitboxID::LeftHand);
		}
		else
		{
			switch (HitScanMode)
			{
			case 1:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Head);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Neck);
				HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
			case 2:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Head);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Chest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftShin);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightShin);
			case 3:
				HitBoxesToScan.push_back((int)CSGOHitboxID::Head);
				HitBoxesToScan.push_back((int)CSGOHitboxID::NeckLower);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftFoot);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LowerChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Stomach);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Pelvis);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftLowerArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightLowerArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightUpperArm);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftThigh);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightThigh);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftShin);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightShin);
				HitBoxesToScan.push_back((int)CSGOHitboxID::Neck);
				HitBoxesToScan.push_back((int)CSGOHitboxID::UpperChest);
				HitBoxesToScan.push_back((int)CSGOHitboxID::RightHand);
				HitBoxesToScan.push_back((int)CSGOHitboxID::LeftHand);
			}
		}
	}
#pragma endregion Get the list of shit to scan

	for (auto HitBoxID : HitBoxesToScan)
	{
		if (AWall)
		{
			Vector Point = GetHitboxPosition(pEntity, HitBoxID);
			float Damage = 0.f;
			Color c = Color(255, 255, 255, 255);
			if (CanHit(Point, &Damage))
			{
				c = Color(0, 255, 0, 255);
				if (Damage >= Menu::Window.RageBotTab.AccuracyMinimumDamage.GetValue())
				{
					return HitBoxID;
				}
			}
		}
		else
		{
			if (GameUtils::IsVisible(hackManager.pLocal(), pEntity, HitBoxID))
				return HitBoxID;
		}
	}

	return -1;
}

void CRageBot::DoNoRecoil(CUserCmd *pCmd)
{
	IClientEntity* pLocal = hackManager.pLocal();
	if (pLocal)
	{
		Vector AimPunch = pLocal->localPlayerExclusive()->GetAimPunchAngle();
		if (AimPunch.Length2D() > 0 && AimPunch.Length2D() < 150)
		{
			pCmd->viewangles -= AimPunch * 2;
			GameUtils::NormaliseViewAngle(pCmd->viewangles);
		}
	}
}

void CRageBot::aimAtPlayer(CUserCmd *pCmd)
{
	IClientEntity* pLocal = hackManager.pLocal();

	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(hackManager.pLocal()->GetActiveWeaponHandle());

	if (!pLocal || !pWeapon)
		return;

	Vector eye_position = pLocal->GetEyePosition();

	float best_dist = pWeapon->GetCSWpnData()->flRange;

	IClientEntity* target = nullptr;

	for (int i = 0; i < Interfaces::Engine->GetMaxClients(); i++)
	{
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		if (TargetMeetsRequirements(pEntity))
		{
			if (Globals::TargetID != -1)
				target = Interfaces::EntList->GetClientEntity(Globals::TargetID);
			else
				target = pEntity;

			Vector target_position = target->GetEyePosition();

			float temp_dist = eye_position.DistTo(target_position);

			if (best_dist > temp_dist)
			{
				best_dist = temp_dist;
				CalcAngle(eye_position, target_position, pCmd->viewangles);
			}
		}
	}
}

bool CRageBot::AimAtPoint(IClientEntity* pLocal, Vector point, CUserCmd *pCmd, bool &bSendPacket)
{
	bool ReturnValue = false;

	if (point.Length() == 0) return ReturnValue;

	Vector angles;
	Vector src = pLocal->GetOrigin() + pLocal->GetViewOffset();

	CalcAngle(src, point, angles);
	GameUtils::NormaliseViewAngle(angles);

	if (angles[0] != angles[0] || angles[1] != angles[1])
	{
		return ReturnValue;
	}


	IsLocked = true;

	Vector ViewOffset = pLocal->GetOrigin() + pLocal->GetViewOffset();
	if (!IsAimStepping)
		LastAimstepAngle = LastAngle;

	float fovLeft = FovToPlayer(ViewOffset, LastAimstepAngle, Interfaces::EntList->GetClientEntity(TargetID), 0);

	if (fovLeft > 25.0f && Menu::Window.RageBotTab.AimbotAimStep.GetState())
	{
		Vector AddAngs = angles - LastAimstepAngle;
		Normalize(AddAngs, AddAngs);
		AddAngs *= 25;
		LastAimstepAngle += AddAngs;
		GameUtils::NormaliseViewAngle(LastAimstepAngle);
		angles = LastAimstepAngle;
	}
	else
	{
		ReturnValue = true;
	}

	if (Menu::Window.RageBotTab.AimbotSilentAim.GetState())
	{
		pCmd->viewangles = angles;
	}

	if (!Menu::Window.RageBotTab.AimbotSilentAim.GetState())
	{
		Interfaces::Engine->SetViewAngles(angles);
	}

	return ReturnValue;
}

namespace AntiAims
{

	void JitterPitch(CUserCmd *pCmd)
	{
		static bool up = true;
		if (up)
		{
			pCmd->viewangles.x = 45;
			up = !up;
		}
		else
		{
			pCmd->viewangles.x = 89;
			up = !up;
		}
	}

	void FakePitch(CUserCmd *pCmd, bool &bSendPacket)
	{
		static int ChokedPackets = -1;
		ChokedPackets++;
		if (ChokedPackets < 1)
		{
			bSendPacket = false;
			pCmd->viewangles.x = 89;
		}
		else
		{
			bSendPacket = true;
			pCmd->viewangles.x = 51;
			ChokedPackets = -1;
		}
	}

	void StaticJitter(CUserCmd *pCmd)
	{
		static bool down = true;
		if (down)
		{
			pCmd->viewangles.x = 179.0f;
			down = !down;
		}
		else
		{
			pCmd->viewangles.x = 89.0f;
			down = !down;
		}
	}

	// Yaws

	void FastSpin(CUserCmd *pCmd)
	{
		static int y2 = -179;
		int spinBotSpeedFast = 100;

		y2 += spinBotSpeedFast;

		if (y2 >= 179)
			y2 = -179;

		pCmd->viewangles.y = y2;
	}

	void FakeEdge(CUserCmd *pCmd, bool &bSendPacket)
	{
		IClientEntity* pLocal = hackManager.pLocal();

		Vector vEyePos = pLocal->GetOrigin() + pLocal->GetViewOffset();

		CTraceFilter filter;
		filter.pSkip = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());

		for (int y = 0; y < 360; y++)
		{
			Vector qTmp(10.0f, pCmd->viewangles.y, 0.0f);
			qTmp.y += y;

			if (qTmp.y > 180.0)
				qTmp.y -= 360.0;
			else if (qTmp.y < -180.0)
				qTmp.y += 360.0;

			GameUtils::NormaliseViewAngle(qTmp);

			Vector vForward;

			VectorAngles(qTmp, vForward);

			float fLength = (19.0f + (19.0f * sinf(DEG2RAD(10.0f)))) + 7.0f;
			vForward *= fLength;

			trace_t tr;

			Vector vTraceEnd = vEyePos + vForward;

			Ray_t ray;

			ray.Init(vEyePos, vTraceEnd);
			Interfaces::Trace->TraceRay(ray, MASK_PLAYERSOLID_BRUSHONLY, &filter, &tr);

			if (tr.fraction != 1.0f)
			{
				Vector angles;

				Vector vNegative = Vector(tr.plane.normal.x * -1.0f, tr.plane.normal.y * -1.0f, tr.plane.normal.z * -1.0f);

				VectorAngles(vNegative, angles);

				GameUtils::NormaliseViewAngle(angles);

				qTmp.y = angles.y;

				GameUtils::NormaliseViewAngle(qTmp);

				trace_t trLeft, trRight;

				Vector vLeft, vRight;
				VectorAngles(qTmp + Vector(0.0f, 30.0f, 0.0f), vLeft);
				VectorAngles(qTmp + Vector(0.0f, 30.0f, 0.0f), vRight);

				vLeft *= (fLength + (fLength * sinf(DEG2RAD(30.0f))));
				vRight *= (fLength + (fLength * sinf(DEG2RAD(30.0f))));

				vTraceEnd = vEyePos + vLeft;

				ray.Init(vEyePos, vTraceEnd);
				Interfaces::Trace->TraceRay(ray, MASK_PLAYERSOLID_BRUSHONLY, &filter, &trLeft);

				vTraceEnd = vEyePos + vRight;

				ray.Init(vEyePos, vTraceEnd);
				Interfaces::Trace->TraceRay(ray, MASK_PLAYERSOLID_BRUSHONLY, &filter, &trRight);

				if ((trLeft.fraction == 1.0f) && (trRight.fraction != 1.0f))
					qTmp.y -= 90.f;
				else if ((trLeft.fraction != 1.0f) && (trRight.fraction == 1.0f))
					qTmp.y += 90.f;

				if (qTmp.y > 180.0)
					qTmp.y -= 360.0;
				else if (qTmp.y < -180.0)
					qTmp.y += 360.0;

				pCmd->viewangles.y = qTmp.y;

				int offset = Menu::Window.RageBotTab.AntiAimOffset.GetValue();

				static int ChokedPackets = -1;
				ChokedPackets++;
				if (ChokedPackets < 1)
				{
					bSendPacket = false; // +=180?
				}
				else
				{
					bSendPacket = true;
					pCmd->viewangles.y -= offset;
					ChokedPackets = -1;
				}
				return;
			}
		}
		pCmd->viewangles.y += 360.0f;
	}

	void BackJitter(CUserCmd *pCmd)
	{
		int random = rand() % 100;

		if (random < 98)

			pCmd->viewangles.y -= 180;

		if (random < 15)
		{
			float change = -70 + (rand() % (int)(140 + 1));
			pCmd->viewangles.y += change;
		}
		if (random == 69)
		{
			float change = -90 + (rand() % (int)(180 + 1));
			pCmd->viewangles.y += change;
		}
	}

	void FakeSideways(CUserCmd *pCmd, bool &bSendPacket)
	{
		static int ChokedPackets = -1;
		ChokedPackets++;
		if (ChokedPackets < 1)
		{
			bSendPacket = false;
			pCmd->viewangles.y += 90;
		}
		else
		{
			bSendPacket = true;
			pCmd->viewangles.y -= 180;
			ChokedPackets = -1;
		}
	}

	void FastSpint(CUserCmd *pCmd)
	{
		int r1 = rand() % 100;
		int r2 = rand() % 1000;

		static bool dir;
		static float current_y = pCmd->viewangles.y;

		if (r1 == 1) dir = !dir;

		if (dir)
			current_y += 15 + rand() % 10;
		else
			current_y -= 15 + rand() % 10;

		pCmd->viewangles.y = current_y;

		if (r1 == r2)
			pCmd->viewangles.y += r1;
	}

	void BackwardJitter(CUserCmd *pCmd)
	{
		int random = rand() % 100;

		if (random < 98)

			pCmd->viewangles.y -= 180;

		if (random < 15)
		{
			float change = -70 + (rand() % (int)(140 + 1));
			pCmd->viewangles.y += change;
		}
		if (random == 69)
		{
			float change = -90 + (rand() % (int)(180 + 1));
			pCmd->viewangles.y += change;
		}
	}

	void Jitter(CUserCmd *pCmd)
	{
		static int jitterangle = 0;

		if (jitterangle <= 1)
		{
			pCmd->viewangles.y += 90;
		}
		else if (jitterangle > 1 && jitterangle <= 3)
		{
			pCmd->viewangles.y -= 90;
		}

		int re = rand() % 4 + 1;


		if (jitterangle <= 1)
		{
			if (re == 4)
				pCmd->viewangles.y += 180;
			jitterangle += 1;
		}
		else if (jitterangle > 1 && jitterangle <= 3)
		{
			if (re == 4)
				pCmd->viewangles.y -= 180;
			jitterangle += 1;
		}
		else
		{
			jitterangle = 0;
		}
	}

	void Backwards(CUserCmd *pCmd)
	{
		pCmd->viewangles.y -= 180.f;
	}

	void FakeStatic(CUserCmd *pCmd, bool &bSendPacket)
	{
		static int ChokedPackets = -1;
		ChokedPackets++;
		if (ChokedPackets < 1)
		{
			bSendPacket = false;
			static int y2 = -179;
			int spinBotSpeedFast = 360.0f / 1.618033988749895f;;

			y2 += spinBotSpeedFast;

			if (y2 >= 179)
				y2 = -179;

			pCmd->viewangles.y = y2;
		}
		else
		{
			bSendPacket = true;
			pCmd->viewangles.y -= 180;
			ChokedPackets = -1;
		}
	}

	void TJitter(CUserCmd *pCmd)
	{
		static bool Turbo = true;
		if (Turbo)
		{
			pCmd->viewangles.y -= 30;
			Turbo = !Turbo;
		}
		else
		{
			pCmd->viewangles.y += 30;
			Turbo = !Turbo;
		}
	}

	void TFake(CUserCmd *pCmd, bool &bSendPacket)
	{
		static int ChokedPackets = -1;
		ChokedPackets++;
		if (ChokedPackets < 1)
		{
			bSendPacket = false;
			pCmd->viewangles.y = -45;
		}
		else
		{
			bSendPacket = true;
			pCmd->viewangles.y = 90;
			ChokedPackets = -1;
		}
	}

	void FakeJitter(CUserCmd* pCmd, bool &bSendPacket)
	{
		static int jitterangle = 0;

		if (jitterangle <= 1)
		{
			pCmd->viewangles.y += 135;
		}
		else if (jitterangle > 1 && jitterangle <= 3)
		{
			pCmd->viewangles.y += 225;
		}

		static int iChoked = -1;
		iChoked++;
		if (iChoked < 1)
		{
			bSendPacket = false;
			if (jitterangle <= 1)
			{
				pCmd->viewangles.y += 45;
				jitterangle += 1;
			}
			else if (jitterangle > 1 && jitterangle <= 3)
			{
				pCmd->viewangles.y -= 45;
				jitterangle += 1;
			}
			else
			{
				jitterangle = 0;
			}
		}
		else
		{
			bSendPacket = true;
			iChoked = -1;
		}
	}


	void Up(CUserCmd *pCmd)
	{
		pCmd->viewangles.x = -89.0f;
	}

	void Zero(CUserCmd *pCmd)
	{
		pCmd->viewangles.x = 1080.f;
	}

	void Static(CUserCmd *pCmd)
	{
		static bool aa1 = false;
		aa1 = !aa1;
		if (aa1)
		{
			static bool turbo = false;
			turbo = !turbo;
			if (turbo)
			{
				pCmd->viewangles.y -= 90;
			}
			else
			{
				pCmd->viewangles.y += 90;
			}
		}
		else
		{
			pCmd->viewangles.y -= 180;
		}
	}

	void fakelowerbody(CUserCmd *pCmd, bool &bSendPacket)
	{
		static bool f_flip = true;
		f_flip = !f_flip;

		if (f_flip)
		{
			pCmd->viewangles.y -= hackManager.pLocal()->GetLowerBodyYaw() + 45.00f;
			bSendPacket = false;
		}
		else if (!f_flip)
		{
			pCmd->viewangles.y += hackManager.pLocal()->GetLowerBodyYaw() - 70.00f;
			bSendPacket = true;
		}
	}

	void FakeSideLBY(CUserCmd *pCmd, bool &bSendPacket)
	{
		int i = 0; i < Interfaces::EntList->GetHighestEntityIndex(); ++i;
		IClientEntity *pEntity = Interfaces::EntList->GetClientEntity(i);
		IClientEntity *pLocal = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());

		static bool isMoving;
		float PlayerIsMoving = abs(pLocal->GetVelocity().Length());
		if (PlayerIsMoving > 0.1) isMoving = true;
		else if (PlayerIsMoving <= 0.1) isMoving = false;

		int flip = (int)floorf(Interfaces::Globals->curtime / 1.1) % 2;
		static bool bFlipYaw;
		float flInterval = Interfaces::Globals->interval_per_tick;
		float flTickcount = pCmd->tick_count;
		float flTime = flInterval * flTickcount;
		if (std::fmod(flTime, 1) == 0.f)
			bFlipYaw = !bFlipYaw;

		if (PlayerIsMoving <= 0.1)
		{
			if (bSendPacket)
			{
				pCmd->viewangles.y += 180.f;
			}
			else
			{
				if (flip)
				{
					pCmd->viewangles.y += bFlipYaw ? 90.f : -90.f;

				}
				else
				{
					pCmd->viewangles.y -= hackManager.pLocal()->GetLowerBodyYaw() + bFlipYaw ? 90.f : -90.f;
				}
			}
		}
		else if (PlayerIsMoving > 0.1)
		{
			if (bSendPacket)
			{
				pCmd->viewangles.y += 180.f;
			}
			else
			{
				pCmd->viewangles.y += 90.f;
			}
		}
	}

	void LBYJitter(CUserCmd* cmd, bool& packet)
	{
		static bool ySwitch;
		static bool jbool;
		static bool jboolt;
		ySwitch = !ySwitch;
		jbool = !jbool;
		jboolt = !jbool;
		if (ySwitch)
		{
			if (jbool)
			{
				if (jboolt)
				{
					cmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() - 78.f;
					packet = false;
				}
				else
				{
					cmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() + 87.f;
					packet = false;
				}
			}
			else
			{
				if (jboolt)
				{
					cmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() - 125.f;
					packet = false;
				}
				else
				{
					cmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() + 125.f;
					packet = false;
				}
			}
		}
		else
		{
			cmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw();
			packet = true;
		}
	}

	void LBYSpin(CUserCmd *pCmd, bool &bSendPacket)
	{
		IClientEntity* pLocal = hackManager.pLocal();
		static int skeet = 145;
		int SpinSpeed = 178;
		static int ChokedPackets = -1;
		ChokedPackets++;
		skeet += SpinSpeed;

		if
			(pCmd->command_number % 9)
		{
			bSendPacket = true;
			if (skeet >= pLocal->GetLowerBodyYaw() + 145);
			skeet = pLocal->GetLowerBodyYaw() - 0;
			ChokedPackets = -1;
		}
		else if
			(pCmd->command_number % 9)
		{
			bSendPacket = false;
			pCmd->viewangles.y += 174;
			ChokedPackets = -1;
		}
		pCmd->viewangles.y = skeet;
	}

	void SlowSpin(CUserCmd *pCmd)
	{
		int r1 = rand() % 100;
		int r2 = rand() % 1000;

		static bool dir;
		static float current_y = pCmd->viewangles.y;

		if (r1 == 1) dir = !dir;

		if (dir)
			current_y += 4 + rand() % 10;
		else
			current_y -= 4 + rand() % 10;

		pCmd->viewangles.y = current_y;

		if (r1 == r2)
			pCmd->viewangles.y += r1;

	}

	void EdgeDetect(CUserCmd* pCmd, bool &bSendPacket)
	{

		IClientEntity* pLocal = hackManager.pLocal();

		CTraceFilter traceFilter;
		traceFilter.pSkip = pLocal;

		bool bEdge = false;

		Vector angle;
		Vector eyePos = pLocal->GetOrigin() + pLocal->GetViewOffset();

		for (float i = 0; i < 360; i++)
		{
			Vector vecDummy(10.f, pCmd->viewangles.y, 0.f);
			vecDummy.y += i;

			Vector forward = vecDummy.Forward();

			float flLength = ((16.f + 3.f) + ((16.f + 3.f) * sin(DEG2RAD(10.f)))) + 7.f;
			forward *= flLength;

			Ray_t ray;
			CGameTrace tr;

			ray.Init(eyePos, (eyePos + forward));
			Interfaces::Trace->EdgeTraceRay(ray, traceFilter, tr, true);

			if (tr.fraction != 1.0f)
			{
				Vector negate = tr.plane.normal;
				negate *= -1;

				Vector vecAng = negate.Angle();

				vecDummy.y = vecAng.y;

				trace_t leftTrace, rightTrace;

				Vector left = (vecDummy + Vector(0, 45, 0)).Forward(); // or 45
				Vector right = (vecDummy - Vector(0, 45, 0)).Forward();

				left *= (flLength * cosf(rad(30)) * 2);
				right *= (flLength * cosf(rad(30)) * 2);

				ray.Init(eyePos, (eyePos + left));
				Interfaces::Trace->EdgeTraceRay(ray, traceFilter, leftTrace, true);

				ray.Init(eyePos, (eyePos + right));
				Interfaces::Trace->EdgeTraceRay(ray, traceFilter, rightTrace, true);

				if ((leftTrace.fraction == 1.f) && (rightTrace.fraction != 1.f))
				{
					vecDummy.y -= 45; // left
				}
				else if ((leftTrace.fraction != 1.f) && (rightTrace.fraction == 1.f))
				{
					vecDummy.y += 45; // right     
				}

				angle.y = vecDummy.y;
				angle.y += 360;
				bEdge = true;
			}
		}

		if (bEdge)
		{
			static bool turbo = true;

			if (Menu::Window.RageBotTab.AntiAimEdge.GetState())
			{
				pCmd->viewangles.y = angle.y;
			}
		}
	}
}

void CorrectMovement(Vector old_angles, CUserCmd* cmd, float old_forwardmove, float old_sidemove)
{
	float delta_view, first_function, second_function;

	if (old_angles.y < 0.f) first_function = 360.0f + old_angles.y;
	else first_function = old_angles.y;

	if (cmd->viewangles.y < 0.0f) second_function = 360.0f + cmd->viewangles.y;
	else second_function = cmd->viewangles.y;

	if (second_function < first_function) delta_view = abs(second_function - first_function);
	else delta_view = 360.0f - abs(first_function - second_function);

	delta_view = 360.0f - delta_view;

	cmd->forwardmove = cos(DEG2RAD(delta_view)) * old_forwardmove + cos(DEG2RAD(delta_view + 90.f)) * old_sidemove;
	cmd->sidemove = sin(DEG2RAD(delta_view)) * old_forwardmove + sin(DEG2RAD(delta_view + 90.f)) * old_sidemove;
}

float GetLatency()
{
	INetChannelInfo *nci = Interfaces::Engine->GetNetChannelInfo();
	if (nci)
	{
		float Latency = nci->GetAvgLatency(FLOW_OUTGOING) + nci->GetAvgLatency(FLOW_INCOMING);
		return Latency;
	}
	else
	{
		return 0.0f;
	}
}
float GetOutgoingLatency()
{
	INetChannelInfo *nci = Interfaces::Engine->GetNetChannelInfo();
	if (nci)
	{
		float OutgoingLatency = nci->GetAvgLatency(FLOW_OUTGOING);
		return OutgoingLatency;
	}
	else
	{
		return 0.0f;
	}
}
float GetIncomingLatency()
{
	INetChannelInfo *nci = Interfaces::Engine->GetNetChannelInfo();
	if (nci)
	{
		float IncomingLatency = nci->GetAvgLatency(FLOW_INCOMING);
		return IncomingLatency;
	}
	else
	{
		return 0.0f;
	}
}

float OldLBY;
float LBYBreakerTimer;
float LastLBYUpdateTime;
bool bSwitch;
float CurrentVelocity(IClientEntity* LocalPlayer)
{
	int vel = LocalPlayer->GetVelocity().Length2D();
	return vel;
}
bool NextLBYUpdate()
{
	IClientEntity* LocalPlayer = hackManager.pLocal();

	float flServerTime = (float)(LocalPlayer->GetTickBase()  * Interfaces::Globals->interval_per_tick);


	if (OldLBY != LocalPlayer->GetLowerBodyYaw())
	{
		LBYBreakerTimer++;
		OldLBY = LocalPlayer->GetLowerBodyYaw();
		bSwitch = !bSwitch;
		LastLBYUpdateTime = flServerTime;
	}

	if (CurrentVelocity(LocalPlayer) > 0.5)
	{
		LastLBYUpdateTime = flServerTime;
		return false;
	}

	if ((LastLBYUpdateTime + 1 - (GetLatency() * 2) < flServerTime) && (LocalPlayer->GetFlags() & FL_ONGROUND))
	{
		if (LastLBYUpdateTime + 1.1 - (GetLatency() * 2) < flServerTime)
		{
			LastLBYUpdateTime += 1.1;
		}
		return true;
	}
	return false;
}

void DoLBYBreak(CUserCmd * pCmd, IClientEntity* pLocal, bool& bSendPacket)
{
	if (!bSendPacket)
	{
		if (NextLBYUpdate())
			pCmd->viewangles.y += 57;
		else
			pCmd->viewangles.y -= 89;
	}
	else
	{
		if (NextLBYUpdate())
			pCmd->viewangles.y -= 35;
		else
			pCmd->viewangles.y += 69;
	}
}

void DoLBYBreakReal(CUserCmd * pCmd, IClientEntity* pLocal, bool& bSendPacket)
{
	if (!bSendPacket)
	{
		if (NextLBYUpdate())
			pCmd->viewangles.y -= 50;
		else
			pCmd->viewangles.y += 130;
	}
	else
	{
		if (NextLBYUpdate())
			pCmd->viewangles.y += 14;
		else
			pCmd->viewangles.y -= 67;
	}
}

void DoRealAA(CUserCmd* pCmd, IClientEntity* pLocal, bool& bSendPacket)
{
	static bool switch2;
	Vector oldAngle = pCmd->viewangles;
	float oldForward = pCmd->forwardmove;
	float oldSideMove = pCmd->sidemove;
	if (!Menu::Window.RageBotTab.AntiAimEnable.GetState())
		return;
	switch (Menu::Window.RageBotTab.AntiAimYaw.GetIndex())
	{
	case 0:
		break;
	case 1:
		// Fast Spin
		AntiAims::FastSpint(pCmd);
		break;
	case 2:
		// Slow Spin
		AntiAims::SlowSpin(pCmd);
		break;
	case 3:
		AntiAims::Jitter(pCmd);
		break;
	case 4:
		// 180 Jitter
		AntiAims::BackJitter(pCmd);
		break;
	case 5:
		// Backward
		AntiAims::Backwards(pCmd);
		break;
	case 6:
		AntiAims::BackwardJitter(pCmd);
		break;
	case 7:
		//Sideways-switch
		if (switch2)
			pCmd->viewangles.y = 69;
		else
			pCmd->viewangles.y = -79;

		switch2 = !switch2;
		break;
	case 8:
		//Sideways
		pCmd->viewangles.y -= 98;
		break;
	case 9:
		pCmd->viewangles.y += 67;
		break;
	case 10:
		pCmd->viewangles.y = pLocal->GetLowerBodyYaw() + rand() % 180 - rand() % 50;
		break;
	case 11:
		AntiAims::LBYJitter(pCmd, bSendPacket);
		break;
	case 12:
		AntiAims::FakeSideLBY(pCmd, bSendPacket);
		break;
	case 13:
		AntiAims::LBYSpin(pCmd, bSendPacket);
		break;
	case 14:
		DoLBYBreakReal(pCmd, pLocal, bSendPacket);
		break;
	}

	static auto RandomReal = false;
	if (RandomReal)
		pCmd->viewangles.y += Menu::Window.RageBotTab.AntiAimOffset.GetValue();
	else
		pCmd->viewangles.y -= Menu::Window.RageBotTab.AntiAimOffset.GetValue();
	RandomReal = !RandomReal;
}

void DoFakeAA(CUserCmd* pCmd, bool& bSendPacket, IClientEntity* pLocal)
{
	static bool switch2;
	Vector oldAngle = pCmd->viewangles;
	float oldForward = pCmd->forwardmove;
	float oldSideMove = pCmd->sidemove;
	if (!Menu::Window.RageBotTab.AntiAimEnable.GetState())
		return;
	switch (Menu::Window.RageBotTab.FakeYaw.GetIndex())
	{
	case 0:
		break;
	case 1:
		// Fast Spin 
		AntiAims::FastSpint(pCmd);
		break;
	case 2:
		// Slow Spin 
		AntiAims::SlowSpin(pCmd);
		break;
	case 3:
		AntiAims::Jitter(pCmd);
		break;
	case 4:
		// 180 Jitter 
		AntiAims::BackJitter(pCmd);
		break;
	case 5:
		// Backward
		AntiAims::Backwards(pCmd);
		break;
	case 6:
		AntiAims::BackwardJitter(pCmd);
		break;
	case 7:
		//Sideways-switch
		if (switch2)
			pCmd->viewangles.y = 90;
		else
			pCmd->viewangles.y = -90;

		switch2 = !switch2;
		break;
	case 8:
		pCmd->viewangles.y -= 90;
		break;
	case 9:
		pCmd->viewangles.y += 90;
		break;
	case 10:
		pCmd->viewangles.y = pLocal->GetLowerBodyYaw() + rand() % 180 - rand() % 50;
		break;
	case 11:
		AntiAims::FakeJitter(pCmd, bSendPacket);
		break;
	case 12:
		AntiAims::FakeSideLBY(pCmd, bSendPacket);
		break;
	case 13:
		AntiAims::LBYSpin(pCmd, bSendPacket);
		break;
	case 14:
		DoLBYBreak(pCmd, pLocal, bSendPacket);
		break;
	}

	static auto RandomFake = false;
	if (RandomFake)
		pCmd->viewangles.y += Menu::Window.RageBotTab.AddFakeYaw.GetValue();
	else
		pCmd->viewangles.y -= Menu::Window.RageBotTab.AddFakeYaw.GetValue();
	RandomFake = !RandomFake;
}

void CRageBot::DoAntiAim(CUserCmd *pCmd, bool &bSendPacket)
{
	IClientEntity* pLocal = hackManager.pLocal();

	if ((pCmd->buttons & IN_USE) || pLocal->GetMoveType() == MOVETYPE_LADDER)
		return;

	if (IsAimStepping || pCmd->buttons & IN_ATTACK)
		return;

	CBaseCombatWeapon* pWeapon = (CBaseCombatWeapon*)Interfaces::EntList->GetClientEntityFromHandle(hackManager.pLocal()->GetActiveWeaponHandle());
	if (pWeapon)
	{
		CSWeaponInfo* pWeaponInfo = pWeapon->GetCSWpnData();

		if (!GameUtils::IsBallisticWeapon(pWeapon))
		{
			if (Menu::Window.RageBotTab.AntiAimKnife.GetState())
			{
				if (!CanOpenFire() || pCmd->buttons & IN_ATTACK2)
					return;
			}
			else
			{
				return;
			}
		}
	}
	if (Menu::Window.RageBotTab.AntiAimTarget.GetState())
	{
		aimAtPlayer(pCmd);
	}
	switch (Menu::Window.RageBotTab.AntiAimPitch.GetIndex())
	{
	case 0:
		break;
	case 1:
		pCmd->viewangles.x = 45.f;
		break;
	case 2:
		AntiAims::JitterPitch(pCmd);
		break;
	case 3:
		pCmd->viewangles.x = 89.000000;
		break;
	case 4:
		AntiAims::Up(pCmd);
		break;
	case 5:
		AntiAims::Zero(pCmd);
		break;
	case 6:
		static auto Random = false;
		if (Random)
			pCmd->viewangles.x += Menu::Window.RageBotTab.CustomPitch.GetValue();
		else
			pCmd->viewangles.x -= Menu::Window.RageBotTab.CustomPitch.GetValue();
		Random = !Random;

	}

	if (Menu::Window.RageBotTab.LBY.GetState() && pLocal->GetVelocity().Length2D() == 0)
	{
#define RandomInt(min, max) (rand() % (max - min + 1) + min)
		static bool fakeantiaim;
		int rand2;
		{
			int var1;
			int var2;
			float var3;

			pCmd->viewangles.y += 179.9;
			var1 = rand() % 100;
			var2 = rand() % (10 - 6 + 1) + 10;
			var3 = var2 - (rand() % var2);
			if (var1 < 60 + (rand() % 14))
				pCmd->viewangles.y -= var3;
			else if (var1 < 100 + (rand() % 14))
				pCmd->viewangles.y += var3;
		}

		if (fakeantiaim)
		{
			rand2 = RandomInt(1, 100);

			if (rand2 < 2.0)
			{
				bSendPacket = true;
				pCmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() + 92.3 - 0 - 31.3;
			}

			else
			{
				bSendPacket = true;
				pCmd->viewangles.y = hackManager.pLocal()->GetLowerBodyYaw() + 91.7;
			}
			fakeantiaim = false;
		}
		else
		{
			bSendPacket = false;
			pCmd->viewangles.y += 154.4;
			fakeantiaim = true;
		}
	}
	else
	{
		static int ChokedPackets = -1;
		ChokedPackets++;
		if (ChokedPackets < 1)
		{
			bSendPacket = true;
			DoFakeAA(pCmd, bSendPacket, pLocal);
		}
		else
		{
			bSendPacket = false;
			DoRealAA(pCmd, pLocal, bSendPacket);
			ChokedPackets = -1;
		}

		if (flipAA)
		{
			pCmd->viewangles.y -= 25;
		}
	}
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class xxitxov {
public:
	int ejjbr;
	bool rsrmfliabpptc;
	double lhptfifezved;
	int quqfmfhwnqjgi;
	xxitxov();
	bool lbsklnqdbzkvyfxg(string rafin, int jqfkwxrrxfyknn, int cxeufcibmbjczz, string eplpbzubn, string wriohslx, bool qrthcanfauty);
	double lpuccvysprswvqgbk(int okntiurnnzizcn, string bnhkqqnhhhcudu, double jpaovtmibdrwm, bool nrljpshzxc, bool kzsfzl, double uyopl, string siuygmwovykuy);
	double epbbrmwbwz(string cjkxmywnmnkmgu, double gannwslvx, double pbzzfo, bool edigflgvz, double vswchmeuchhdc, int hqilec, double xppgym, bool numtqboigz, string wnknuys);
	void fuayndgkkpvxhunoyjwfssgyo(bool wquitnqhxb);
	void awjhcggjvzrwenmkqntiqc(int pgxtmltugqhispg, string ygmytfamjchpes, int odrxdem, string wkmbhlpln, bool uluiot, double jvpptuzcopoik, string innbmionc, double nhiemec);
	void gqmkzezomoihimsrbhmn(string xljhjz, double ucmwgsrsa, bool pjgtfp, bool mjtuphrxcs, string sazbpxcxnqfvagg, int agrznouuxaajig);
	void qmotffussstictx(double chmhkchgqgv, bool bacfopy, int mqkrullib, bool eodipftlcaxccl, int yixxgdtdzubhlbe, int tmwyeypdowhhtc, string qznxwtijbqfhd, int vulxxldhlgg, string sniqnzxlpy, bool dsnmzs);
	int ppncurydjnrrrgeg(double agndieufo, string osjrxlknuucwdsy);
	bool ujukfayiapwtrxspackfigi(int txhmnakta, double qugxm, int ymwxmgigckvgoeu, bool qhofp, int admyjmyfqhq, double kcfqprkypjf, double beocznqangie, double fdkppvo, double npozqskx, string ytrnjtege);
	double iicnbhoeuiyjeenbgxck(double tkrqoqfvc, bool xeieoqyb, string zmbdeqo);

protected:
	bool xkirr;
	bool stbbjupvozgpk;

	string sliluokismhfxsxwpycnftisg(double uzpccjjozm, double vyaccgqi, double oguyuwdbwp, double rxcsztsvqtcml, bool sxxblf, string xexjngkbmaztq, double ukutjqnma);
	int ntvdlmbzylprxdwqprezh(double hlulgrbsrq, string vnebtmtf, bool rcvvtltj, int cneqmu, bool fztppxziwihpen, string ofirx, bool xvukws, double zkigvipdwkqbi, double keakn, double vjdshdjbnol);
	double uztmtnnapsjemf(int rxpqienyip, string kuszcki, int yivgkegzn, bool rsgirfpuh, double xcdtcmiaiahm, string mmjflqfokkjx, int sjhfzthqf);
	double ajcwgczavzyxzedbhziewrhih(bool qlhtfh, double omedvo, double sgwkqu, bool myrsulckw, int lnyomojdilpktgb, bool ltytim, double esegsvyuzqwhw, bool dcvdokn, string pbxsjhhtpgfh, bool ceaytajtdtvalw);
	double edbbdcphsj(bool szorwtwrzvdr, int wkznioyznzb, int pyyol, int qchlkhut);
	double kejkuadjpeyayoovzqyqaopby(bool ynmzermbymwlflo, double ytzmkntbpxlx, int iumfqrxmjgpa, int ypeivlvgjxpse, bool jbeqfecmcl, int qxrtuxv, bool mlant, bool bpoudnuaqpx, double abwmnuxm);
	void irivoazxdsmrkvtannophmjsd(string weoibzas);

private:
	double vtumiuzlaw;

	void qreyfjlxaffiavj(int zpjmvs, bool lvyrheplmun, double rvyrtfxnelp, string ftqembegoqs, double pbthprfqpyiul);
	int avauwocpddegat(string bwmrj, double zjlvedvy, double jrqucgglkusl, int ohomkgx, int jurmmrw);
	int dochhhawtmgxbve(double uqbcwt, string gtmnudvymijfx, bool pabpzuktoxna, bool ftapiaojrn, string xckrwpevixr, bool esekfkufkcan, double hmiojzqwfiwrel, string oyndyfqfwnk, string uoacgjbci);
	void lzeqigilbdjh(bool kpjnrhzhf, double ubbthjm, bool rvrwkpespzgpmql, bool fkznzj, double wncsuxaclvcmn, string eenmfmracj, double nhfzhnpea);
	int ppylngygqflb(double yvxzxiylhmqi, int lgxwzeiymfusi, int seqzkcr, int ipuatksktqnx, int yocswhvgrhlyo, int fpsglsgbfnttfq, double dbzsibhw, bool iirdfwoaruigev, bool tylxapqfvzopbqk);
	bool pvhlmpalbldrptbognncr(int didivrjf, string epmboknzhhqa, int tzfmkfnwrwwl, int uonoynfbmhsdw, string ufpdshkn, string pfjyvnqupqvlz);
	double iabfcsfbkvfzc(int dbrojqwznqjhnn, string cnkbywdhkme);
	void vjtcvjszbzeqyfwvmtri(int pfatc, string upptryfeejhu, double qcakkgdawssqkq, string smfpmomiq, string mrhyyyqsqz, bool rgnzvbmq, int ympifkghgy, string gkalcjddyli, int ufuopu);
	string tpkvcrzqnxnrnayylcwybwr(int vepnlgopi, bool mwnbruicbinbi, string yggaerzlbki, bool lnxdaak, string pemekpv, bool ahctmcdekpgs, double sferzcvegx, string vwipz, double ozdwvspbbegv);
	double esrtbttkkq(double mblnmascogf, string xgeqm, double jdoytepqcchog, bool ovmaficqfrnyus, string alenllmkqec);

};


void xxitxov::qreyfjlxaffiavj(int zpjmvs, bool lvyrheplmun, double rvyrtfxnelp, string ftqembegoqs, double pbthprfqpyiul) {
	string uiwvnpaxoe = "";
	bool qsuehetqshnr = true;
	double qupdy = 11231;
	double ztcfofxqnuihk = 63357;
	bool odcszlinajc = false;
	string guaidyzwqu = "uxrrwzanucwwbrzgzsiksknvsyzbvsnotksfcy";
	string ruxriel = "ngalqmibfvpzpcuejbksvqmmjjppbyfvktyzgrgyrwqafwcwdrhdglrmt";
	string viqjyefpo = "qqcomvuodnsfknwlpbfduiojgeybnrswgwhqdbyzkqxohothhrgeovhviewrbnrfovrzg";
	int iliky = 4395;
	int qozfhidaxbr = 1355;
	if (true != true) {
		int frsilney;
		for (frsilney = 84; frsilney > 0; frsilney--) {
			continue;
		}
	}
	if (1355 == 1355) {
		int zxodhlrzg;
		for (zxodhlrzg = 1; zxodhlrzg > 0; zxodhlrzg--) {
			continue;
		}
	}
	if (false != false) {
		int cttnnb;
		for (cttnnb = 48; cttnnb > 0; cttnnb--) {
			continue;
		}
	}
	if (true == true) {
		int dsvhftms;
		for (dsvhftms = 2; dsvhftms > 0; dsvhftms--) {
			continue;
		}
	}
	if (string("") != string("")) {
		int doyd;
		for (doyd = 75; doyd > 0; doyd--) {
			continue;
		}
	}

}

int xxitxov::avauwocpddegat(string bwmrj, double zjlvedvy, double jrqucgglkusl, int ohomkgx, int jurmmrw) {
	int aemkbpnptziwi = 708;
	string kisnstazqrkxzz = "smyjotxckoiohvrtwkslbdzuni";
	double szxwvfnfhcqa = 49698;
	if (49698 != 49698) {
		int rgytcr;
		for (rgytcr = 33; rgytcr > 0; rgytcr--) {
			continue;
		}
	}
	if (49698 == 49698) {
		int bc;
		for (bc = 37; bc > 0; bc--) {
			continue;
		}
	}
	if (49698 == 49698) {
		int mzsb;
		for (mzsb = 43; mzsb > 0; mzsb--) {
			continue;
		}
	}
	if (708 != 708) {
		int yofwnl;
		for (yofwnl = 99; yofwnl > 0; yofwnl--) {
			continue;
		}
	}
	if (string("smyjotxckoiohvrtwkslbdzuni") != string("smyjotxckoiohvrtwkslbdzuni")) {
		int bqawity;
		for (bqawity = 50; bqawity > 0; bqawity--) {
			continue;
		}
	}
	return 20081;
}

int xxitxov::dochhhawtmgxbve(double uqbcwt, string gtmnudvymijfx, bool pabpzuktoxna, bool ftapiaojrn, string xckrwpevixr, bool esekfkufkcan, double hmiojzqwfiwrel, string oyndyfqfwnk, string uoacgjbci) {
	bool wicaswfrzkdb = true;
	bool hdqubdvxprwmbr = false;
	double knobwamzhxeme = 10917;
	double xorcoolaaqxhx = 21788;
	int llnyuvsurtarqku = 4927;
	bool lnlroxjc = true;
	int ohgczbyxv = 235;
	int dibwajftmdei = 2706;
	bool kxbzgareovdmxf = true;
	if (true == true) {
		int buc;
		for (buc = 82; buc > 0; buc--) {
			continue;
		}
	}
	if (true != true) {
		int el;
		for (el = 1; el > 0; el--) {
			continue;
		}
	}
	return 71499;
}

void xxitxov::lzeqigilbdjh(bool kpjnrhzhf, double ubbthjm, bool rvrwkpespzgpmql, bool fkznzj, double wncsuxaclvcmn, string eenmfmracj, double nhfzhnpea) {
	string hurgktqsb = "pbvlqtedkpeezcfkmnkeljxvhthvtbbwudybramwaokgvhbrpjbprpsudlnfeknamtzslgven";
	string qpucydpmwm = "gxpjizlycjetmtjfxibchgqmn";
	int yyuarstlwpvno = 1797;
	int aylwlazphapcetl = 3378;
	string hiabf = "hgcqyzftgyxirlgmnkzrryjcwmybiovzhekhdqqoblvwxjqifxwpfs";
	bool urhrkycjqn = true;
	if (1797 != 1797) {
		int pricj;
		for (pricj = 5; pricj > 0; pricj--) {
			continue;
		}
	}
	if (1797 == 1797) {
		int dmjplucfg;
		for (dmjplucfg = 60; dmjplucfg > 0; dmjplucfg--) {
			continue;
		}
	}
	if (string("pbvlqtedkpeezcfkmnkeljxvhthvtbbwudybramwaokgvhbrpjbprpsudlnfeknamtzslgven") == string("pbvlqtedkpeezcfkmnkeljxvhthvtbbwudybramwaokgvhbrpjbprpsudlnfeknamtzslgven")) {
		int pyra;
		for (pyra = 4; pyra > 0; pyra--) {
			continue;
		}
	}
	if (string("pbvlqtedkpeezcfkmnkeljxvhthvtbbwudybramwaokgvhbrpjbprpsudlnfeknamtzslgven") != string("pbvlqtedkpeezcfkmnkeljxvhthvtbbwudybramwaokgvhbrpjbprpsudlnfeknamtzslgven")) {
		int rb;
		for (rb = 24; rb > 0; rb--) {
			continue;
		}
	}

}

int xxitxov::ppylngygqflb(double yvxzxiylhmqi, int lgxwzeiymfusi, int seqzkcr, int ipuatksktqnx, int yocswhvgrhlyo, int fpsglsgbfnttfq, double dbzsibhw, bool iirdfwoaruigev, bool tylxapqfvzopbqk) {
	int ooonafvzk = 1547;
	string fpyodu = "qrmwzzbghyddurkmykwcazcqcogjkvwabrjnxzhnneyjnlaouzdthufzssoxwiwzrslwhgyxgobwhmdxxoirrbjfxbvutjwizh";
	bool pjshxmiykdn = false;
	double ndanr = 3117;
	double omxtfdmvzl = 30485;
	if (3117 == 3117) {
		int uqnhxqafb;
		for (uqnhxqafb = 99; uqnhxqafb > 0; uqnhxqafb--) {
			continue;
		}
	}
	return 59641;
}

bool xxitxov::pvhlmpalbldrptbognncr(int didivrjf, string epmboknzhhqa, int tzfmkfnwrwwl, int uonoynfbmhsdw, string ufpdshkn, string pfjyvnqupqvlz) {
	bool puywzitis = false;
	string tvlzfdsjtxxdsf = "epuonxxdvdtghoytlzujhkpdslclcbzcjvnxopogvoscgiyhmhwxznumwdhkpfnkztcguxdirycsauflgczzhuhrugvtekzqzsw";
	double kmmkkuymm = 21490;
	double ifvjybfniuke = 454;
	if (21490 != 21490) {
		int ktpnm;
		for (ktpnm = 15; ktpnm > 0; ktpnm--) {
			continue;
		}
	}
	return true;
}

double xxitxov::iabfcsfbkvfzc(int dbrojqwznqjhnn, string cnkbywdhkme) {
	double rjmfgcqzdlnkqlr = 6807;
	bool ozfrwnejqmhbsry = false;
	string zznwrqdtelz = "dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh";
	if (string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh") == string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh")) {
		int zro;
		for (zro = 15; zro > 0; zro--) {
			continue;
		}
	}
	if (string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh") != string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh")) {
		int gi;
		for (gi = 9; gi > 0; gi--) {
			continue;
		}
	}
	if (string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh") == string("dswcwokiashuhujbfkyqcgkqfmswnbsluaubjtwukfzrsbqngglrjvlkvwcdhfh")) {
		int khfwjv;
		for (khfwjv = 96; khfwjv > 0; khfwjv--) {
			continue;
		}
	}
	return 70266;
}

void xxitxov::vjtcvjszbzeqyfwvmtri(int pfatc, string upptryfeejhu, double qcakkgdawssqkq, string smfpmomiq, string mrhyyyqsqz, bool rgnzvbmq, int ympifkghgy, string gkalcjddyli, int ufuopu) {
	bool ckgktelgziy = false;
	string bmwoqs = "vuscfee";
	double bmplrghzohq = 12706;
	string uywzamethce = "lumjqmgczkyxfvxxlkuwfkthzaboqulxzrmlnejkrhwtmiextaaigtbmgfrxrershmgbpkdejuxzevsnxmkutepptufcbdc";
	string xflulw = "dydqhdtggen";
	int pltcsn = 1898;
	double tdkbztxl = 20032;
	double mikcoohtnmtqlw = 34768;
	if (string("lumjqmgczkyxfvxxlkuwfkthzaboqulxzrmlnejkrhwtmiextaaigtbmgfrxrershmgbpkdejuxzevsnxmkutepptufcbdc") != string("lumjqmgczkyxfvxxlkuwfkthzaboqulxzrmlnejkrhwtmiextaaigtbmgfrxrershmgbpkdejuxzevsnxmkutepptufcbdc")) {
		int sw;
		for (sw = 24; sw > 0; sw--) {
			continue;
		}
	}
	if (string("lumjqmgczkyxfvxxlkuwfkthzaboqulxzrmlnejkrhwtmiextaaigtbmgfrxrershmgbpkdejuxzevsnxmkutepptufcbdc") != string("lumjqmgczkyxfvxxlkuwfkthzaboqulxzrmlnejkrhwtmiextaaigtbmgfrxrershmgbpkdejuxzevsnxmkutepptufcbdc")) {
		int guliwpae;
		for (guliwpae = 80; guliwpae > 0; guliwpae--) {
			continue;
		}
	}
	if (string("dydqhdtggen") == string("dydqhdtggen")) {
		int kpzw;
		for (kpzw = 65; kpzw > 0; kpzw--) {
			continue;
		}
	}
	if (string("vuscfee") == string("vuscfee")) {
		int gp;
		for (gp = 86; gp > 0; gp--) {
			continue;
		}
	}
	if (string("dydqhdtggen") == string("dydqhdtggen")) {
		int jdbsrwofhj;
		for (jdbsrwofhj = 6; jdbsrwofhj > 0; jdbsrwofhj--) {
			continue;
		}
	}

}

string xxitxov::tpkvcrzqnxnrnayylcwybwr(int vepnlgopi, bool mwnbruicbinbi, string yggaerzlbki, bool lnxdaak, string pemekpv, bool ahctmcdekpgs, double sferzcvegx, string vwipz, double ozdwvspbbegv) {
	int paxpmybmwfm = 1239;
	string qmftkudplrisuh = "hmtiseoddlqzdbmnjwtk";
	bool letexc = true;
	string yatqhwmrnavgei = "mdigfyqlrgfbmbpwcnlwiafkqybghkrfglk";
	bool bzkhistmpajnrb = false;
	int ilufpzn = 1989;
	if (1239 != 1239) {
		int phubccc;
		for (phubccc = 72; phubccc > 0; phubccc--) {
			continue;
		}
	}
	if (string("hmtiseoddlqzdbmnjwtk") != string("hmtiseoddlqzdbmnjwtk")) {
		int prf;
		for (prf = 32; prf > 0; prf--) {
			continue;
		}
	}
	if (1989 != 1989) {
		int drytmy;
		for (drytmy = 73; drytmy > 0; drytmy--) {
			continue;
		}
	}
	if (string("mdigfyqlrgfbmbpwcnlwiafkqybghkrfglk") != string("mdigfyqlrgfbmbpwcnlwiafkqybghkrfglk")) {
		int exrx;
		for (exrx = 10; exrx > 0; exrx--) {
			continue;
		}
	}
	if (1989 != 1989) {
		int iyik;
		for (iyik = 81; iyik > 0; iyik--) {
			continue;
		}
	}
	return string("fahpiofbdlbithxc");
}

double xxitxov::esrtbttkkq(double mblnmascogf, string xgeqm, double jdoytepqcchog, bool ovmaficqfrnyus, string alenllmkqec) {
	double rmmcmtnffphytf = 25687;
	double wrhxfaydf = 24011;
	int ategqgmjwbg = 5303;
	int saxtxcjjzblfaf = 2225;
	double qognkhbdr = 24374;
	bool iloihljtxfdg = true;
	int gdujb = 1175;
	double sjpkml = 45396;
	double dcykahuujktl = 16756;
	if (1175 != 1175) {
		int hernotqqff;
		for (hernotqqff = 45; hernotqqff > 0; hernotqqff--) {
			continue;
		}
	}
	if (24374 != 24374) {
		int lpiyeovv;
		for (lpiyeovv = 51; lpiyeovv > 0; lpiyeovv--) {
			continue;
		}
	}
	if (24374 == 24374) {
		int clmfcwpvl;
		for (clmfcwpvl = 60; clmfcwpvl > 0; clmfcwpvl--) {
			continue;
		}
	}
	return 64090;
}

string xxitxov::sliluokismhfxsxwpycnftisg(double uzpccjjozm, double vyaccgqi, double oguyuwdbwp, double rxcsztsvqtcml, bool sxxblf, string xexjngkbmaztq, double ukutjqnma) {
	int ylnxjvkksi = 579;
	string ewnsmjqskixxye = "vmymfyajydecwcxsyqolulxxzvzkeseynbwcwuvmmddpdbtrohqxqgssqlslwqnpcogvq";
	double hpgpttdol = 6036;
	int ihsvh = 1647;
	if (6036 == 6036) {
		int gdkdkl;
		for (gdkdkl = 84; gdkdkl > 0; gdkdkl--) {
			continue;
		}
	}
	if (579 != 579) {
		int dsspffiw;
		for (dsspffiw = 88; dsspffiw > 0; dsspffiw--) {
			continue;
		}
	}
	if (1647 != 1647) {
		int kfulka;
		for (kfulka = 19; kfulka > 0; kfulka--) {
			continue;
		}
	}
	if (6036 != 6036) {
		int cpqrfyloby;
		for (cpqrfyloby = 12; cpqrfyloby > 0; cpqrfyloby--) {
			continue;
		}
	}
	if (string("vmymfyajydecwcxsyqolulxxzvzkeseynbwcwuvmmddpdbtrohqxqgssqlslwqnpcogvq") != string("vmymfyajydecwcxsyqolulxxzvzkeseynbwcwuvmmddpdbtrohqxqgssqlslwqnpcogvq")) {
		int xvcx;
		for (xvcx = 44; xvcx > 0; xvcx--) {
			continue;
		}
	}
	return string("zl");
}

int xxitxov::ntvdlmbzylprxdwqprezh(double hlulgrbsrq, string vnebtmtf, bool rcvvtltj, int cneqmu, bool fztppxziwihpen, string ofirx, bool xvukws, double zkigvipdwkqbi, double keakn, double vjdshdjbnol) {
	bool ipecatxnk = true;
	double gzvblyh = 3846;
	bool xbttm = false;
	string bungczrtckke = "eiwpzgwmedjjhdfkincy";
	int vmwyfiv = 5361;
	double ihygjkblseacb = 13298;
	return 56028;
}

double xxitxov::uztmtnnapsjemf(int rxpqienyip, string kuszcki, int yivgkegzn, bool rsgirfpuh, double xcdtcmiaiahm, string mmjflqfokkjx, int sjhfzthqf) {
	string zgdmnr = "mkmiiwpsruxwaqopjkfhnbaynirfxcbkawhptlbjtjgnhcwgwwwypsejizogpyheveqpnpzplcgcve";
	string fgisxntncolyay = "acmustuiszvjwvzexejzcqruektakquobgfhnjxheecqsezfabirtgnysdrdcwwoozkfudxsygaypijhqcspospzg";
	bool gjkoxwzl = false;
	int exyojnecg = 2248;
	bool tzaslcxfjfxu = true;
	double eknhvvnbvoyalqb = 63271;
	return 25352;
}

double xxitxov::ajcwgczavzyxzedbhziewrhih(bool qlhtfh, double omedvo, double sgwkqu, bool myrsulckw, int lnyomojdilpktgb, bool ltytim, double esegsvyuzqwhw, bool dcvdokn, string pbxsjhhtpgfh, bool ceaytajtdtvalw) {
	double vdkaehkkocehw = 47957;
	double zpggcxutar = 9440;
	bool tauidmspvjmr = false;
	bool ekmkrkfyysnoaw = true;
	int wzhztrhb = 248;
	bool bgixgpz = true;
	int upnvpwlr = 4352;
	if (47957 == 47957) {
		int jxuph;
		for (jxuph = 59; jxuph > 0; jxuph--) {
			continue;
		}
	}
	if (4352 != 4352) {
		int vhi;
		for (vhi = 100; vhi > 0; vhi--) {
			continue;
		}
	}
	if (true != true) {
		int trvc;
		for (trvc = 56; trvc > 0; trvc--) {
			continue;
		}
	}
	if (true == true) {
		int rhslz;
		for (rhslz = 96; rhslz > 0; rhslz--) {
			continue;
		}
	}
	if (4352 == 4352) {
		int aqogueyn;
		for (aqogueyn = 98; aqogueyn > 0; aqogueyn--) {
			continue;
		}
	}
	return 53078;
}

double xxitxov::edbbdcphsj(bool szorwtwrzvdr, int wkznioyznzb, int pyyol, int qchlkhut) {
	return 63762;
}

double xxitxov::kejkuadjpeyayoovzqyqaopby(bool ynmzermbymwlflo, double ytzmkntbpxlx, int iumfqrxmjgpa, int ypeivlvgjxpse, bool jbeqfecmcl, int qxrtuxv, bool mlant, bool bpoudnuaqpx, double abwmnuxm) {
	bool wvunlewl = true;
	bool hqtew = false;
	bool xleoydakwqm = true;
	int bxzzgib = 1247;
	string wxszfmbkrow = "woukdbbtgxitjakhsuymjirvyahmfplzioeqst";
	bool jvaxlpakphz = true;
	double bsjzelddrhmfdtl = 29146;
	int tyxog = 3539;
	bool xuqukfmimlguo = true;
	bool ckucbuts = false;
	return 78049;
}

void xxitxov::irivoazxdsmrkvtannophmjsd(string weoibzas) {
	int cwvbllbvcajih = 3237;
	bool tipyxmdxbv = false;
	int xhdrkdvy = 3852;
	string tgwufywa = "voianojypkavcyteowhgxlzjmbdfhcaeejajdovkwxyykcrzmnpgowcgwsuemirubriwvermiobzqnmxqkyekgxfcitqlnhqgpse";
	bool dekrayozspxs = false;
	double lcpgafrfrcd = 52740;
	string isxkzqvvifyz = "qahnuwwsylxrfzwpzhjtselghscpxsfwbftaqbvtupjsneflfplrddchgqoovw";
	double kslmbo = 21789;
	int jbftpqqtt = 1351;
	string mbhhjciy = "xrkhybnzkwlremqtrcoqppggrqfzoovevznsuodjrinbxexdxlfoxvzbnpwpqzsxdmssstytmzh";
	if (false != false) {
		int kzomreb;
		for (kzomreb = 52; kzomreb > 0; kzomreb--) {
			continue;
		}
	}

}

bool xxitxov::lbsklnqdbzkvyfxg(string rafin, int jqfkwxrrxfyknn, int cxeufcibmbjczz, string eplpbzubn, string wriohslx, bool qrthcanfauty) {
	string kqqkricj = "pewzwimvhrgpgzpvhrfghdrzkwaecaijpdlulfawsyvnr";
	double gyotiqx = 34002;
	int xiywujedrra = 3958;
	double ntigodhy = 39905;
	bool zkozqdqw = true;
	bool yolbfvz = true;
	if (true != true) {
		int gpop;
		for (gpop = 43; gpop > 0; gpop--) {
			continue;
		}
	}
	if (string("pewzwimvhrgpgzpvhrfghdrzkwaecaijpdlulfawsyvnr") != string("pewzwimvhrgpgzpvhrfghdrzkwaecaijpdlulfawsyvnr")) {
		int rvthed;
		for (rvthed = 50; rvthed > 0; rvthed--) {
			continue;
		}
	}
	if (34002 == 34002) {
		int iodeogn;
		for (iodeogn = 74; iodeogn > 0; iodeogn--) {
			continue;
		}
	}
	if (34002 != 34002) {
		int jbndkfvcu;
		for (jbndkfvcu = 14; jbndkfvcu > 0; jbndkfvcu--) {
			continue;
		}
	}
	if (true == true) {
		int ypaa;
		for (ypaa = 38; ypaa > 0; ypaa--) {
			continue;
		}
	}
	return false;
}

double xxitxov::lpuccvysprswvqgbk(int okntiurnnzizcn, string bnhkqqnhhhcudu, double jpaovtmibdrwm, bool nrljpshzxc, bool kzsfzl, double uyopl, string siuygmwovykuy) {
	return 7955;
}

double xxitxov::epbbrmwbwz(string cjkxmywnmnkmgu, double gannwslvx, double pbzzfo, bool edigflgvz, double vswchmeuchhdc, int hqilec, double xppgym, bool numtqboigz, string wnknuys) {
	bool xogzukl = false;
	string sgavvxtznnpx = "vsmfjrxzhe";
	if (string("vsmfjrxzhe") != string("vsmfjrxzhe")) {
		int moem;
		for (moem = 67; moem > 0; moem--) {
			continue;
		}
	}
	if (string("vsmfjrxzhe") == string("vsmfjrxzhe")) {
		int nbgec;
		for (nbgec = 33; nbgec > 0; nbgec--) {
			continue;
		}
	}
	return 6699;
}

void xxitxov::fuayndgkkpvxhunoyjwfssgyo(bool wquitnqhxb) {
	string omtyxrxkcwymll = "vulwredsqnprwlqnimhiajcdywvvoxkkgwzxmuidez";
	double orrrqlbitao = 20710;
	double yjrzsqifipnh = 34008;
	double pexxahxzac = 82097;
	string wkfseney = "yacareaekimtylsgighxpgdexovkvpgpndbgghbstathqfipxbvqkudghqcnkbwbusgpcaqpjcgdockyxajse";
	bool wmcdvtpirewfcl = false;
	if (20710 == 20710) {
		int apdxdxeatu;
		for (apdxdxeatu = 85; apdxdxeatu > 0; apdxdxeatu--) {
			continue;
		}
	}
	if (false == false) {
		int ucqtelvwtz;
		for (ucqtelvwtz = 44; ucqtelvwtz > 0; ucqtelvwtz--) {
			continue;
		}
	}
	if (false == false) {
		int rh;
		for (rh = 76; rh > 0; rh--) {
			continue;
		}
	}
	if (string("vulwredsqnprwlqnimhiajcdywvvoxkkgwzxmuidez") == string("vulwredsqnprwlqnimhiajcdywvvoxkkgwzxmuidez")) {
		int pelidbxxp;
		for (pelidbxxp = 43; pelidbxxp > 0; pelidbxxp--) {
			continue;
		}
	}
	if (string("vulwredsqnprwlqnimhiajcdywvvoxkkgwzxmuidez") == string("vulwredsqnprwlqnimhiajcdywvvoxkkgwzxmuidez")) {
		int errrx;
		for (errrx = 90; errrx > 0; errrx--) {
			continue;
		}
	}

}

void xxitxov::awjhcggjvzrwenmkqntiqc(int pgxtmltugqhispg, string ygmytfamjchpes, int odrxdem, string wkmbhlpln, bool uluiot, double jvpptuzcopoik, string innbmionc, double nhiemec) {
	bool lvbwvxyat = true;
	if (true == true) {
		int nc;
		for (nc = 87; nc > 0; nc--) {
			continue;
		}
	}
	if (true != true) {
		int ri;
		for (ri = 31; ri > 0; ri--) {
			continue;
		}
	}
	if (true == true) {
		int biqpwjbss;
		for (biqpwjbss = 88; biqpwjbss > 0; biqpwjbss--) {
			continue;
		}
	}

}

void xxitxov::gqmkzezomoihimsrbhmn(string xljhjz, double ucmwgsrsa, bool pjgtfp, bool mjtuphrxcs, string sazbpxcxnqfvagg, int agrznouuxaajig) {
	double riwtfv = 7485;
	bool yguef = false;
	int kesqunxsdy = 779;
	if (779 != 779) {
		int zeqxv;
		for (zeqxv = 36; zeqxv > 0; zeqxv--) {
			continue;
		}
	}
	if (false == false) {
		int iul;
		for (iul = 53; iul > 0; iul--) {
			continue;
		}
	}
	if (false == false) {
		int pamaho;
		for (pamaho = 13; pamaho > 0; pamaho--) {
			continue;
		}
	}
	if (false == false) {
		int iblhphytc;
		for (iblhphytc = 46; iblhphytc > 0; iblhphytc--) {
			continue;
		}
	}

}

void xxitxov::qmotffussstictx(double chmhkchgqgv, bool bacfopy, int mqkrullib, bool eodipftlcaxccl, int yixxgdtdzubhlbe, int tmwyeypdowhhtc, string qznxwtijbqfhd, int vulxxldhlgg, string sniqnzxlpy, bool dsnmzs) {
	bool atcfbyd = true;
	string eddciwyd = "oszdylxdfbzcqsxunpzburzdghkuksioxzcalwbpa";
	bool mrtiutqyo = false;
	string ibxpvihz = "ysdgqtueevyylmajaindjssntppjonyxvbhexipzwbmsyljcszdufdmprrwfjmsrc";
	bool venwouadrftyy = false;
	bool xxdvxfyivylcznk = false;
	bool deatu = false;
	bool umbxjh = true;
	string swgloewv = "rlkhrkpfybgigrgfkvsrtxgmwdyulqdlbngmvyfducusmuqobmokfagpkvucpmtkeczlzutmvipbery";
	string vkreusiehobqui = "cefjjjhgtkuasokvbynsfxjskyvzfozaxygoirzcyppozhdsgn";
	if (true == true) {
		int rfttwztfuq;
		for (rfttwztfuq = 62; rfttwztfuq > 0; rfttwztfuq--) {
			continue;
		}
	}
	if (true == true) {
		int ruywco;
		for (ruywco = 86; ruywco > 0; ruywco--) {
			continue;
		}
	}
	if (string("oszdylxdfbzcqsxunpzburzdghkuksioxzcalwbpa") != string("oszdylxdfbzcqsxunpzburzdghkuksioxzcalwbpa")) {
		int lbqsaxid;
		for (lbqsaxid = 62; lbqsaxid > 0; lbqsaxid--) {
			continue;
		}
	}

}

int xxitxov::ppncurydjnrrrgeg(double agndieufo, string osjrxlknuucwdsy) {
	string gifobdrlh = "msrbsxqarbtodfzvstczqhezkgwclgiyhguzcncpeoenpisoeqhbihkfqksgxzmtnkzlwtbxu";
	int fbotjo = 675;
	double weiiakzmf = 9070;
	string scdjpapyqmntey = "cjwanmhslppkzjmajqrajlklswgoonqrrskrbemjvutgostotybayhjnctmcwobhkbhlzhnqosiggsdkgqk";
	string qaeuiptxet = "seqviazzlulkwqjkiypapxmqphnmtovlbpxhjhvysleievzhj";
	if (string("seqviazzlulkwqjkiypapxmqphnmtovlbpxhjhvysleievzhj") != string("seqviazzlulkwqjkiypapxmqphnmtovlbpxhjhvysleievzhj")) {
		int mtqvyxk;
		for (mtqvyxk = 17; mtqvyxk > 0; mtqvyxk--) {
			continue;
		}
	}
	if (string("msrbsxqarbtodfzvstczqhezkgwclgiyhguzcncpeoenpisoeqhbihkfqksgxzmtnkzlwtbxu") != string("msrbsxqarbtodfzvstczqhezkgwclgiyhguzcncpeoenpisoeqhbihkfqksgxzmtnkzlwtbxu")) {
		int ngl;
		for (ngl = 35; ngl > 0; ngl--) {
			continue;
		}
	}
	if (9070 != 9070) {
		int njnmo;
		for (njnmo = 15; njnmo > 0; njnmo--) {
			continue;
		}
	}
	if (9070 == 9070) {
		int thlca;
		for (thlca = 46; thlca > 0; thlca--) {
			continue;
		}
	}
	if (9070 == 9070) {
		int lozrfmj;
		for (lozrfmj = 8; lozrfmj > 0; lozrfmj--) {
			continue;
		}
	}
	return 67076;
}

bool xxitxov::ujukfayiapwtrxspackfigi(int txhmnakta, double qugxm, int ymwxmgigckvgoeu, bool qhofp, int admyjmyfqhq, double kcfqprkypjf, double beocznqangie, double fdkppvo, double npozqskx, string ytrnjtege) {
	int ysjpxukylhyt = 509;
	bool lpjcl = false;
	double illotlherhko = 41025;
	double szsiuhnm = 10833;
	int uslftt = 946;
	int zijjwgsokuzmce = 3837;
	int jftmilddgdf = 4580;
	bool tthre = false;
	double cslgiv = 14300;
	if (946 == 946) {
		int fstxrsszvo;
		for (fstxrsszvo = 65; fstxrsszvo > 0; fstxrsszvo--) {
			continue;
		}
	}
	if (946 != 946) {
		int uprjdfbr;
		for (uprjdfbr = 16; uprjdfbr > 0; uprjdfbr--) {
			continue;
		}
	}
	return false;
}

double xxitxov::iicnbhoeuiyjeenbgxck(double tkrqoqfvc, bool xeieoqyb, string zmbdeqo) {
	bool xxopxc = false;
	int gflzmot = 7561;
	double rvlzj = 1790;
	double zzlmggkxgbw = 11988;
	int anuvqtzbskwxngf = 6825;
	if (7561 == 7561) {
		int ztg;
		for (ztg = 87; ztg > 0; ztg--) {
			continue;
		}
	}
	if (6825 == 6825) {
		int wjuactlthl;
		for (wjuactlthl = 47; wjuactlthl > 0; wjuactlthl--) {
			continue;
		}
	}
	if (false != false) {
		int qv;
		for (qv = 69; qv > 0; qv--) {
			continue;
		}
	}
	if (false == false) {
		int vhwshndwn;
		for (vhwshndwn = 69; vhwshndwn > 0; vhwshndwn--) {
			continue;
		}
	}
	return 80311;
}

xxitxov::xxitxov() {
	this->lbsklnqdbzkvyfxg(string("wlnbighjosdsmhpaqlohrcvook"), 595, 2272, string("pptuswhmoardgdoremkwvmrj"), string("kvodhjcoxgbeepnftfslcnixisxtlikxoommzbfzemkhtcrmnb"), false);
	this->lpuccvysprswvqgbk(3223, string("hhclbyxtiatrriuammvplovnnbzexlywzsfmpmpevnwevsqgrpjkeljufkxovmhrvqfhsgezgixbtedetzlx"), 40990, true, true, 9212, string("htzylowedtkvfzqpujlijpxflhopreiotydnikycm"));
	this->epbbrmwbwz(string("mimqhzmcsbdgjasswhyvxhxbieliwkxltwjelpuqpkmuzfefbbisenorbagrmmmasdwuj"), 35023, 31117, true, 23497, 3909, 7353, true, string("lhwtjiyvjvolpdoxjhzqluhtvwxuyjyyjullcpwprpslcohgluctbl"));
	this->fuayndgkkpvxhunoyjwfssgyo(true);
	this->awjhcggjvzrwenmkqntiqc(2970, string("iotkedourbhudaaxojizodkiooxtusrfwgjvbmrdtxxngilotinyxtkyngljnpyskiigsokzcaatoajzwznwsnpdqkbi"), 269, string("qpttxmotmlkmwjullyblfduavvqqgxmtzethsuzvwbzngbywbtmxuxpprwdpyvufiuvwtinwfmzo"), false, 12760, string("ssnczwyqzkvnerqsvuycjgyalbpyaqozbwfptrgkxywlgqgwrnperogcogqvjpcpdrufduqvkyzjnspdcdcadvpdqauuhfv"), 6131);
	this->gqmkzezomoihimsrbhmn(string("kddwjycbysgnydatzosjcjjdtr"), 42, true, true, string("oylzuklyzosexpqzecsojrmzjyvtsbwaoycyyrzuzflqxmnygajlwtuvjqadnnhgydixvqapszyggdpdvqjgshdpncmgqporjxth"), 2614);
	this->qmotffussstictx(20638, true, 3991, true, 1978, 161, string("ztadnojfiofqhbctotxgjuuenlwbkdztdmsypzahjohwgmqsnihevcrxfenzjcvvwuoxcalczdnpmqfnlzvkbeyde"), 1680, string("ygpsofjausrjndsorjlvzkxfajwusforzktybjkoofrcpyrikddmrjqkjkd"), true);
	this->ppncurydjnrrrgeg(68647, string("csqeuqhcodyckfzbmkulqmqfvuupbwkwxezkonvhialsvmfseofgxmsgsusfn"));
	this->ujukfayiapwtrxspackfigi(4195, 52921, 1550, true, 3007, 38213, 37430, 41456, 5763, string("mxlcvv"));
	this->iicnbhoeuiyjeenbgxck(10538, false, string("qfghvrstekdjztatetrzgzgwrrsfivpfgvxcezzepolkkypqhtvhogqpgbycwupesrjtugxjaxjtzufgrdlr"));
	this->sliluokismhfxsxwpycnftisg(9529, 10598, 6143, 46126, false, string("umjnseiyylyhnloynsasueezpqiiuayvqtgqhbrpuhsyawjnrunbfpgcmllzqtybypkwzgxnllfdpxjeufiiftfovhadmugtwb"), 627);
	this->ntvdlmbzylprxdwqprezh(13160, string("nxjkwpragmlpriccvgidgetyeryemqcaaffxwzmgoqjdkripyazsfhuvwhzgmzgwauiqwkvfmmzbictpxv"), false, 4310, false, string("tarmgapqxextr"), false, 24823, 32724, 6480);
	this->uztmtnnapsjemf(8642, string("xhoznoeuecwrdwy"), 3693, false, 11867, string("kkzaznucefwaxtyr"), 2403);
	this->ajcwgczavzyxzedbhziewrhih(true, 27074, 10710, false, 4914, false, 32428, true, string("hlvfxqsdcfqrgghkvxwvqqhjxbvdyqzdwhzvbxbvrloozfxnxpzepwokccpvxsg"), true);
	this->edbbdcphsj(true, 1302, 1113, 1358);
	this->kejkuadjpeyayoovzqyqaopby(true, 30356, 856, 1023, true, 2017, false, false, 8454);
	this->irivoazxdsmrkvtannophmjsd(string("agzggscfvrvaduvlsrmrkjdldkppelhckrjnlqlqwbcguyswvoanfglqdhsvankoiumwc"));
	this->qreyfjlxaffiavj(3239, true, 40150, string("tjgpumx"), 16623);
	this->avauwocpddegat(string("jhemoqlolzwsntujubfdsouuuldpczqgmuvhzzpfnmyzn"), 26738, 41327, 680, 1672);
	this->dochhhawtmgxbve(45729, string("zlwtqrtbbtivtuaohjbwchcomsvglguryzsbgcdxicbyocwkveznwvlfpwwtgikihbg"), true, true, string("glqvjnuybjqrrjkzatlositucxtfmdkxnaelxggrfmflvkxgigmrrogkvrykvosmcojfyymgyaqxjnbjvmkjxsu"), true, 13474, string("azzjsipoicicofsgfiwwr"), string("xysrqxsxirzzlvdq"));
	this->lzeqigilbdjh(false, 73508, false, true, 47111, string("zixfdfpmjw"), 30523);
	this->ppylngygqflb(33956, 2181, 257, 338, 6646, 7363, 20434, false, false);
	this->pvhlmpalbldrptbognncr(218, string("oljfmbf"), 1312, 6464, string("ruoionmpmttscaakklksxxgpdwdlbujfr"), string("rmqhbkxyqvrfntjuxcqgilkptzkylxtebtnwkludswhezslkupjyitjl"));
	this->iabfcsfbkvfzc(96, string("izedizbnkggmsysfldvbtwertscakzojtxwjzdvwadfizcftajdflfidoqxyyzsimffnaxex"));
	this->vjtcvjszbzeqyfwvmtri(208, string("oloyrphfgzpenozbylyltymuni"), 48524, string("qokqyjycrggeyedehabsmmmqxzdehqyclzrwnsnwagxyrohshfoxufxhdqznmzfxnpwotqibabisysuuzrmmqsiftnptyqydg"), string("kzxvdytzhxlggyaafmlzqhynad"), false, 6239, string("ozxsrt"), 6676);
	this->tpkvcrzqnxnrnayylcwybwr(4081, true, string("vflzezaxwduaudqvqjfjno"), true, string("qtoxbkkqgiwlzwkjqyjqmbouwzkekcryzdownerbynujjqdpbysxmvtxsziabvxqwvockmzrmrguxykbxuswrlgvbekfjrnsw"), false, 32512, string("edqfwgushnxexwavuajofgjvtoyt"), 22926);
	this->esrtbttkkq(17857, string("uulcvkmjgtqueuvinjecczmqfjewhoybprmetqnyxgongsnxnpeekwfyllgpbx"), 13782, true, string("shtztlrdsefzzutrdwcpboeruysibwxoqejvtwnfrcvuazdtubpzwmfpflhofqknjkrpdazwgfjvfoqzdp"));
}

